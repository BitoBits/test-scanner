<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vercel Scanner</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-white p-6">
  <div id="root"></div>
  
  <script type="module">
    const TIMEFRAMES = ['15m', '1h', '4h', '12h', '1d'];
    const ALERT_FEEDS = [
      { id: 'feed1', name: '15m + 1h', timeframes: ['15m', '1h'] },
      { id: 'feed2', name: '4h + 12h', timeframes: ['4h', '12h'] },
      { id: 'feed3', name: '1D', timeframes: ['1d'] }
    ];

    // Get timezone info
    const getTimezone = () => {
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const offset = -new Date().getTimezoneOffset() / 60;
      const offsetStr = offset >= 0 ? `UTC+${offset}` : `UTC${offset}`;
      // Get timezone abbreviation if possible
      const date = new Date();
      const tzAbbr = date.toLocaleTimeString('en', { timeZoneName: 'short' }).split(' ').pop();
      return { tz, offset, offsetStr, tzAbbr };
    };

    const storage = {
      async get(key) {
        try {
          const value = localStorage.getItem(key);
          return value ? { value } : null;
        } catch (e) {
          return null;
        }
      },
      async set(key, value) {
        try {
          localStorage.setItem(key, value);
          return { key, value };
        } catch (e) {
          return null;
        }
      }
    };

    // Retry helper with exponential backoff
    async function fetchWithRetry(url, maxRetries = 3, delay = 1000, skipOnError = false) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const response = await fetch(url);
          if (response.status === 429) {
            // Rate limited - wait longer
            const waitTime = delay * (i + 1) * 3; // Increased wait time
            await new Promise(resolve => setTimeout(resolve, waitTime));
            continue;
          }
          if (response.status === 400 || response.status === 404) {
            // Bad request or not found - skip silently if requested
            if (skipOnError) return null;
            throw new Error(`HTTP ${response.status}`);
          }
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          return await response.json();
        } catch (error) {
          // Handle CORS and network errors
          if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
            if (skipOnError) return null;
            throw error;
          }
          if (i === maxRetries - 1) throw error;
          await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
        }
      }
    }

    class Scanner {
      constructor() {
        this.state = {
          loading: false,
          progress: { current: 0, total: 0 },
          initialized: false,
          alerts: { feed1: [], feed2: [], feed3: [] },
          pausedFeeds: { feed1: false, feed2: false, feed3: false },
          showInfo: false,
          showExplorer: false,
          selectedSymbol: null,
          coinSearch: '',
          timeFilter: 'all', // 'all', '30d', 'month', '7d'
          lastFetch: {},
          symbols: [],
          showImportPrompt: false,
          showCandlePrompt: false,
          candleCount: 100,
          showFetchDialog: false,
          showDataAvailability: false
        };
        this.wsRefs = [];
        this.lastOIData = {};
        this.oiHistory = {}; // { symbol: { timeframe: { top50Positive: [], top50Negative: [] } } }
        this.timestamps = {};
        this.timestampCache = {};
        this.audioEl = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIGGS78OScTgwOTqXh8LdjHAU2jNXxzn0vBSh+zPDaklALFF7A7+mlVRIIQ5zd8sFuIwUqgM3y2Ik3CBhju+/gnE4MDU6l4fC3YxwFOIzV8c59LwUofszw2pJQCxNewO/ppVUSCEOc3fLBbiMFKoDN8tmJNwgYY7vv4JxODA1OpeHwt2McBTiM1fHOfS8FKH7M8NqSUAsUXsDv6aVVEghDnN3ywW4jBSqAzfLZiTcIGGO77+CcTgwNTqXh8LdjHAU4jNXxzn0vBSh+zPDaklALFF7A7+mlVRIIQ5zd8sFuIwUqgM3y2Yk3CBhju+/gnE4MDU6l4fC3YxwFOIzV8c59LwUofszw2pJQCxRewO/ppVUSCEOc3fLBbiMFKoDN8tmJNwgYY7vv4JxODA1OpeHwt2McBTiM1fHOfS8FKH7M8NqSUAsUXsDv6aVVEghDnN3ywW4jBSqAzfLZiTcIGGO77+CcTgwNTqXh8LdjHAU4jNXxzn0vBSh+zPDaklALFF7A7+mlVRIIQ5zd8sFuIwUqgM3y2Yk3CBhju+/gnE4MDU6l4fC3YxwFOIzV8c59LwUofszw2pJQCxRewO/ppVUSCEOc3fLBbiMFKoDN8tmJNwgYY7vv4JxODA1OpeHwt2McBTiM1fHOfS8FKH7M8NqSUAsUXsDv6aVVEghDnN3ywW4jBSqAzfLZiTcIGGO77+CcTgwNTqXh8LdjHAU4jNXxzn0vBSh+zPDaklALFF7A7+mlVRIIQ5zd8sFuIwUqgM3y2Yk3CBhju+/gnE4MDU6l4fC3YxwFOIzV8c59LwUofszw2pJQCxRewO/ppVUSCEOc3fLBbiMFKoDN8tmJNwgYY7vv4JxODA1OpeHwt2McBTiM1fHOfS8FKH7M8NqSUAsUXsDv6aVVEghDnN3ywW4jBSqAzfLZiTcIGGO77+CcTgwNTqXh8LdjHAU4jNXxzn0vBSh+zPDaklALFF7A7+mlVRIIQ5zd8sFuIwUqgM3y2Yk3CBhju+/gnE4MDU6l4fC3YxwFOIzV8c59LwUofszw2pJQCxRewO/ppVUSCEOc3fLBbiMFKoDN8tmJNwgYY7vv4JxODA1OpeHwt2McBTiM1fHOfS8FKH7M8NqSUAsUXsDv6aVVEghDnN3ywW4jBSqAzfLZiTcIGGO77+CcTgwNTqXh8LdjHAU4jNXxzn0vBSh+zPDaklALFF7A7+mlVRIIQ5zd8sFuIwUqgM3y');
        this.timezone = getTimezone();
        this.init();
      }

      async init() {
        await this.loadStoredData();
        
        // Check if there's any stored data
        const hasStoredData = this.state.initialized || 
                              Object.keys(this.oiHistory).length > 0 ||
                              Object.keys(this.timestamps).length > 0;
        
        if (!this.state.initialized) {
          // If no initialization but might have partial data, or completely new
          if (hasStoredData) {
            // Has some stored data - ask about import/download
            this.state.showImportPrompt = true;
          } else {
            // Completely new - show import prompt first, then candle prompt after init
            this.state.showImportPrompt = true;
          }
        } else {
          // Already initialized - show data availability and ask if want more
          this.state.showDataAvailability = true;
        }
        
        this.render();
        if (this.state.initialized && this.state.symbols.length > 0) {
          this.startOIPolling();
        }
      }

      async loadStoredData() {
        try {
          const stored = await storage.get('vercel-scanner-init');
          if (stored) {
            const data = JSON.parse(stored.value);
            this.state.initialized = data.initialized;
            this.state.lastFetch = data.lastFetch || {};
            this.state.symbols = data.symbols || [];
          }
          
          const oiData = await storage.get('vercel-scanner-oi');
          if (oiData) {
            this.oiHistory = JSON.parse(oiData.value);
          }
          
          const tsData = await storage.get('vercel-scanner-timestamps');
          if (tsData) {
            this.timestamps = JSON.parse(tsData.value);
          }
          
          const cacheData = await storage.get('vercel-scanner-timestamp-cache');
          if (cacheData) {
            this.timestampCache = JSON.parse(cacheData.value);
          }
          
          const lastOIData = await storage.get('vercel-scanner-last-oi');
          if (lastOIData) {
            this.lastOIData = JSON.parse(lastOIData.value);
          }
        } catch (error) {
          console.log('No stored data found');
        }
      }

      async saveAllData() {
        await storage.set('vercel-scanner-oi', JSON.stringify(this.oiHistory));
        await storage.set('vercel-scanner-timestamps', JSON.stringify(this.timestamps));
        await storage.set('vercel-scanner-timestamp-cache', JSON.stringify(this.timestampCache));
        await storage.set('vercel-scanner-last-oi', JSON.stringify(this.lastOIData));
      }

      updateTimestampCache() {
        const cache = {};
        
        TIMEFRAMES.forEach(tf => {
          ['volume', 'candle', 'oi'].forEach(metric => {
            const key = `${tf}_${metric}`;
            let oldestMin = null, oldestMax = null, lastUpdateMin = null;
            let oldestMinCoin = null, oldestMaxCoin = null;
            
            Object.keys(this.timestamps).forEach(symbol => {
              if (this.timestamps[symbol][tf] && this.timestamps[symbol][tf][metric]) {
                const ts = this.timestamps[symbol][tf][metric];
                const oldest = new Date(ts.oldest);
                const lastUpdate = new Date(ts.lastUpdate);
                
                if (!oldestMin || oldest < oldestMin) {
                  oldestMin = oldest;
                  oldestMinCoin = symbol;
                }
                if (!oldestMax || oldest > oldestMax) {
                  oldestMax = oldest;
                  oldestMaxCoin = symbol;
                }
                if (!lastUpdateMin || lastUpdate < lastUpdateMin) {
                  lastUpdateMin = lastUpdate;
                }
              }
            });
            
            if (oldestMin) {
              cache[key] = {
                oldestMin: oldestMin.toISOString(),
                oldestMax: oldestMax.toISOString(),
                oldestMinCoin,
                oldestMaxCoin,
                lastUpdateMin: lastUpdateMin.toISOString()
              };
            }
          });
        });
        
        this.timestampCache = cache;
      }

      startOIPolling() {
        setInterval(() => this.pollOpenInterest(), 300000);
        this.pollOpenInterest();
      }

       async pollOpenInterest() {
         if (!this.state.symbols || this.state.symbols.length === 0) return;
         
         for (const symbol of this.state.symbols.slice(0, 50)) {
           try {
             await new Promise(resolve => setTimeout(resolve, 100));
             const response = await fetch(`https://fapi.binance.com/fapi/v1/openInterest?symbol=${symbol}`);
             
             if (!response.ok) {
               // Skip symbols that don't support OI (400, 404, etc.)
               if (response.status === 400 || response.status === 404) {
                 continue;
               }
               throw new Error(`HTTP ${response.status}`);
             }
             
             const data = await response.json();
             
             if (data.openInterest) {
              const currentOIUsdt = parseFloat(data.openInterest);
              let currentOICoin = data.sumOpenInterest ? parseFloat(data.sumOpenInterest) : null;
              
              if (!currentOICoin) {
                try {
                  const priceResponse = await fetch(`https://fapi.binance.com/fapi/v1/ticker/price?symbol=${symbol}`);
                  const priceData = await priceResponse.json();
                  if (priceData.price) {
                    currentOICoin = currentOIUsdt / parseFloat(priceData.price);
                  }
                } catch (e) {
                  currentOICoin = 0;
                }
              }
              
              const prevOI = this.lastOIData[symbol];
              
              if (prevOI && prevOI.usdt > 0) {
                const oiChangePercent = ((currentOIUsdt - prevOI.usdt) / prevOI.usdt) * 100;
                
                TIMEFRAMES.forEach(tf => {
                  if (!this.oiHistory[symbol]) this.oiHistory[symbol] = {};
                  if (!this.oiHistory[symbol][tf]) {
                    this.oiHistory[symbol][tf] = {
                      top50Positive: [],
                      top50Negative: []
                    };
                  }
                  
                  const change = {
                    usdt: currentOIUsdt,
                    coin: currentOICoin,
                    percent: oiChangePercent,
                    timestamp: new Date().toISOString()
                  };
                  
                  // Update top 50 positive
                  if (oiChangePercent > 0) {
                    this.oiHistory[symbol][tf].top50Positive.push(change);
                    this.oiHistory[symbol][tf].top50Positive.sort((a, b) => b.percent - a.percent);
                    this.oiHistory[symbol][tf].top50Positive = this.oiHistory[symbol][tf].top50Positive.slice(0, 50);
                  }
                  
                  // Update top 50 negative
                  if (oiChangePercent < 0) {
                    this.oiHistory[symbol][tf].top50Negative.push(change);
                    this.oiHistory[symbol][tf].top50Negative.sort((a, b) => a.percent - b.percent);
                    this.oiHistory[symbol][tf].top50Negative = this.oiHistory[symbol][tf].top50Negative.slice(0, 50);
                  }
                  
                  // Update timestamp
                  if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
                  if (!this.timestamps[symbol][tf]) this.timestamps[symbol][tf] = {};
                  if (!this.timestamps[symbol][tf].oi) {
                    this.timestamps[symbol][tf].oi = { oldest: change.timestamp, lastUpdate: change.timestamp };
                  } else {
                    this.timestamps[symbol][tf].oi.lastUpdate = change.timestamp;
                  }
                });
                
                if (Math.abs(oiChangePercent) > 5) {
                  this.addAlert('feed1', {
                    symbol,
                    type: 'oiChange',
                    subtype: 'Significant OI Change',
                    value: oiChangePercent.toFixed(2) + '%',
                    timeframe: '5m',
                    timestamp: new Date()
                  });
                }
              }
              
              this.lastOIData[symbol] = { usdt: currentOIUsdt, coin: currentOICoin || 0 };
            }
          } catch (error) {
            console.error(`Error polling OI for ${symbol}:`, error);
          }
        }
        
        this.updateTimestampCache();
        await this.saveAllData();
      }

      async importData(file) {
        try {
          const text = await file.text();
          const data = JSON.parse(text);
          
          if (data.extremes) {
            const currentExtremes = await storage.get('vercel-scanner-extremes');
            let extremesDB = currentExtremes ? JSON.parse(currentExtremes.value) : {};
            
            Object.keys(data.extremes).forEach(symbol => {
              if (!extremesDB[symbol]) extremesDB[symbol] = {};
              Object.keys(data.extremes[symbol]).forEach(tf => {
                if (!extremesDB[symbol][tf]) extremesDB[symbol][tf] = { volume: { top50: [] }, candleSize: { top50: [] } };
                
                const mergedVol = [...(extremesDB[symbol][tf].volume.top50 || []), ...(data.extremes[symbol][tf].volume.top50 || [])];
                mergedVol.sort((a, b) => b.volume - a.volume);
                extremesDB[symbol][tf].volume.top50 = mergedVol.slice(0, 50);
                
                const mergedCandle = [...(extremesDB[symbol][tf].candleSize.top50 || []), ...(data.extremes[symbol][tf].candleSize.top50 || [])];
                mergedCandle.sort((a, b) => b.candleSize - a.candleSize);
                extremesDB[symbol][tf].candleSize.top50 = mergedCandle.slice(0, 50);
              });
            });
            
            await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
          }
          
          if (data.oiHistory) {
            Object.keys(data.oiHistory).forEach(symbol => {
              if (!this.oiHistory[symbol]) this.oiHistory[symbol] = {};
              Object.keys(data.oiHistory[symbol]).forEach(tf => {
                if (!this.oiHistory[symbol][tf]) {
                  this.oiHistory[symbol][tf] = { top50Positive: [], top50Negative: [] };
                }
                
                const mergedPos = [...this.oiHistory[symbol][tf].top50Positive, ...(data.oiHistory[symbol][tf].top50Positive || [])];
                mergedPos.sort((a, b) => b.percent - a.percent);
                this.oiHistory[symbol][tf].top50Positive = mergedPos.slice(0, 50);
                
                const mergedNeg = [...this.oiHistory[symbol][tf].top50Negative, ...(data.oiHistory[symbol][tf].top50Negative || [])];
                mergedNeg.sort((a, b) => a.percent - b.percent);
                this.oiHistory[symbol][tf].top50Negative = mergedNeg.slice(0, 50);
              });
            });
          }
          
          if (data.timestamps) {
            Object.keys(data.timestamps).forEach(symbol => {
              if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
              Object.keys(data.timestamps[symbol]).forEach(tf => {
                if (!this.timestamps[symbol][tf]) this.timestamps[symbol][tf] = {};
                Object.keys(data.timestamps[symbol][tf]).forEach(metric => {
                  if (!this.timestamps[symbol][tf][metric]) {
                    this.timestamps[symbol][tf][metric] = data.timestamps[symbol][tf][metric];
                  } else {
                    const existing = this.timestamps[symbol][tf][metric];
                    const imported = data.timestamps[symbol][tf][metric];
                    this.timestamps[symbol][tf][metric] = {
                      oldest: new Date(existing.oldest) < new Date(imported.oldest) ? existing.oldest : imported.oldest,
                      lastUpdate: new Date(existing.lastUpdate) > new Date(imported.lastUpdate) ? existing.lastUpdate : imported.lastUpdate
                    };
                  }
                });
              });
            });
          }
          
          if (data.lastFetch) {
            Object.keys(data.lastFetch).forEach(key => {
              if (!this.state.lastFetch[key] || new Date(data.lastFetch[key]) > new Date(this.state.lastFetch[key])) {
                this.state.lastFetch[key] = data.lastFetch[key];
              }
            });
          }
          
          if (data.symbols) {
            const symbolSet = new Set([...this.state.symbols, ...data.symbols]);
            this.state.symbols = Array.from(symbolSet);
          }
          
          // Update initialized state if imported data has symbols
          if (data.symbols && data.symbols.length > 0 && !this.state.initialized) {
            this.state.initialized = true;
            await storage.set('vercel-scanner-init', JSON.stringify({
              initialized: true,
              lastFetch: this.state.lastFetch,
              symbols: this.state.symbols
            }));
          }
          
          this.updateTimestampCache();
          await this.saveAllData();
          
          alert('Data imported successfully!');
          this.state.showImportPrompt = false;
          
          // After import, check if they want to fetch more data
          const hasData = Object.keys(this.timestamps).length > 0;
          if (!hasData) {
            this.state.showCandlePrompt = true;
          }
          
          this.render();
          
          // Start OI polling if initialized
          if (this.state.initialized && this.state.symbols.length > 0) {
            this.startOIPolling();
            this.startLiveMonitoring(this.state.symbols);
          }
        } catch (error) {
          alert('Error importing data: ' + error.message);
        }
      }

      exportData() {
        const data = {
          extremes: null,
          oiHistory: this.oiHistory,
          timestamps: this.timestamps,
          lastFetch: this.state.lastFetch,
          symbols: this.state.symbols,
          exportDate: new Date().toISOString()
        };
        
        storage.get('vercel-scanner-extremes').then(result => {
          if (result) {
            data.extremes = JSON.parse(result.value);
          }
          
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `vercel-scanner-data-${new Date().toISOString().split('T')[0]}.json`;
          a.click();
          URL.revokeObjectURL(url);
        });
      }

      async fillGaps() {
        if (!this.state.initialized || this.state.symbols.length === 0) {
          alert('Please initialize scanner first');
          return;
        }
        
        this.state.loading = true;
        this.state.progress = { current: 0, total: 0, message: 'Finding missing data...' };
        this.render();
        
        try {
          const extremesData = await storage.get('vercel-scanner-extremes');
          const extremesDB = extremesData ? JSON.parse(extremesData.value) : {};
          
          const missing = [];
          this.state.symbols.forEach(symbol => {
            TIMEFRAMES.forEach(tf => {
              const key = `${symbol}_${tf}`;
              const lastFetchTime = this.state.lastFetch[key] ? new Date(this.state.lastFetch[key]) : null;
              const now = new Date();
              
              if (!lastFetchTime || (now - lastFetchTime) > 3600000) {
                missing.push({ symbol, tf });
              }
            });
          });
          
          this.state.progress.total = missing.length;
          this.state.progress.message = `Filling ${missing.length} gaps...`;
          this.render();
          
          for (let i = 0; i < missing.length; i += 15) {
            const batch = missing.slice(i, i + 15);
            await Promise.all(batch.map(async ({ symbol, tf }) => {
              try {
                this.state.progress.message = `Fetching ${symbol} ${tf}...`;
                this.render();
                
                const klines = await fetchWithRetry(
                  `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${tf}&limit=1000`
                );
                
                if (Array.isArray(klines) && klines.length > 0) {
                  if (!extremesDB[symbol]) extremesDB[symbol] = {};
                  if (!extremesDB[symbol][tf]) extremesDB[symbol][tf] = { volume: { top50: [] }, candleSize: { top50: [] } };
                  
                  const processed = klines.map(k => ({
                    time: k[0],
                    volume: parseFloat(k[5]),
                    candleSize: ((parseFloat(k[2]) - parseFloat(k[3])) / parseFloat(k[3])) * 100
                  }));
                  
                  const volumeSorted = [...processed].sort((a, b) => b.volume - a.volume);
                  const candleSorted = [...processed].sort((a, b) => b.candleSize - a.candleSize);
                  
                  const existingVol = extremesDB[symbol][tf].volume.top50 || [];
                  const existingCandle = extremesDB[symbol][tf].candleSize.top50 || [];
                  
                  const mergedVol = [...existingVol, ...volumeSorted].sort((a, b) => b.volume - a.volume).slice(0, 50);
                  const mergedCandle = [...existingCandle, ...candleSorted].sort((a, b) => b.candleSize - a.candleSize).slice(0, 50);
                  
                  extremesDB[symbol][tf] = {
                    volume: { top50: mergedVol },
                    candleSize: { top50: mergedCandle }
                  };
                  
                  if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
                  if (!this.timestamps[symbol][tf]) this.timestamps[symbol][tf] = {};
                  
                  const oldestTime = new Date(processed[0].time);
                  const newestTime = new Date(processed[processed.length - 1].time);
                  
                  if (!this.timestamps[symbol][tf].volume) {
                    this.timestamps[symbol][tf].volume = { oldest: oldestTime.toISOString(), lastUpdate: newestTime.toISOString() };
                  } else {
                    const existingOldest = new Date(this.timestamps[symbol][tf].volume.oldest);
                    this.timestamps[symbol][tf].volume.oldest = oldestTime < existingOldest ? oldestTime.toISOString() : this.timestamps[symbol][tf].volume.oldest;
                    this.timestamps[symbol][tf].volume.lastUpdate = newestTime.toISOString();
                  }
                  
                  if (!this.timestamps[symbol][tf].candle) {
                    this.timestamps[symbol][tf].candle = { oldest: oldestTime.toISOString(), lastUpdate: newestTime.toISOString() };
                  } else {
                    const existingOldest = new Date(this.timestamps[symbol][tf].candle.oldest);
                    this.timestamps[symbol][tf].candle.oldest = oldestTime < existingOldest ? oldestTime.toISOString() : this.timestamps[symbol][tf].candle.oldest;
                    this.timestamps[symbol][tf].candle.lastUpdate = newestTime.toISOString();
                  }
                  
                  this.state.lastFetch[`${symbol}_${tf}`] = new Date().toISOString();
                }
                
                this.state.progress.current++;
                this.render();
              } catch (error) {
                console.error(`Error filling gap for ${symbol} ${tf}:`, error);
                this.state.progress.current++;
                this.render();
              }
            }));
            
            // Delay between batches to respect rate limits
            if (i + 15 < missing.length) {
              await new Promise(resolve => setTimeout(resolve, 100));
            }
          }
          
          await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
          await storage.set('vercel-scanner-timestamps', JSON.stringify(this.timestamps));
          await storage.set('vercel-scanner-init', JSON.stringify({
            initialized: true,
            lastFetch: this.state.lastFetch,
            symbols: this.state.symbols
          }));
          
          this.updateTimestampCache();
          await this.saveAllData();
          
          this.state.loading = false;
          this.render();
          alert('Gaps filled successfully!');
        } catch (error) {
          console.error('Gap filling error:', error);
          alert('Error: ' + error.message);
          this.state.loading = false;
          this.render();
        }
      }

      async initializeScanner() {
        console.log('Initialize button clicked');
        this.state.loading = true;
        this.state.progress = { current: 0, total: 0, message: 'Initializing scanner...' };
        this.state.showImportPrompt = false;
        this.render();

        try {
          const exchangeInfo = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo').then(r => r.json());
          const perpetuals = exchangeInfo.symbols
            .filter(s => s.contractType === 'PERPETUAL' && !s.symbol.includes('_') && s.symbol.endsWith('USDT') && !s.symbol.includes('USDC'))
            .map(s => s.symbol);

          this.state.symbols = perpetuals;
          
          // Initialize empty structure, but preserve existing data if it exists
          const fetchData = {};
          const existingExtremes = await storage.get('vercel-scanner-extremes');
          const extremesDB = existingExtremes ? JSON.parse(existingExtremes.value) : {};
          
          // Only initialize if symbol doesn't exist, preserve existing data
          perpetuals.forEach(symbol => {
            if (!extremesDB[symbol]) {
              extremesDB[symbol] = {};
            }
            TIMEFRAMES.forEach(tf => {
              if (!extremesDB[symbol][tf]) {
                extremesDB[symbol][tf] = {
                  volume: { top50: [] },
                  candleSize: { top50: [] }
                };
              }
            });
          });

          await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
          await storage.set('vercel-scanner-timestamps', JSON.stringify(this.timestamps));
          await storage.set('vercel-scanner-init', JSON.stringify({
            initialized: true,
            lastFetch: fetchData,
            symbols: perpetuals
          }));

          this.state.lastFetch = fetchData;
          this.state.initialized = true;
          this.state.loading = false;
          
          // Check if there's existing data, if not ask about fetching
          const hasData = Object.keys(this.timestamps).length > 0 || 
                         Object.keys(this.oiHistory).length > 0;
          if (!hasData) {
            this.state.showCandlePrompt = true;
          }
          
          this.updateTimestampCache();
          await this.saveAllData();
          
          this.render();
          this.startLiveMonitoring(perpetuals);
        } catch (error) {
          console.error('Initialization error:', error);
          alert('Error: ' + error.message);
          this.state.loading = false;
          this.render();
        }
      }

      calculateTimeEstimate(candleCount, symbolsCount) {
        if (!symbolsCount || symbolsCount === 0) return 'N/A';
        
        // More realistic estimates based on actual API behavior
        // Each symbol needs: 5 timeframes × 2 (volume/candle + OI) = 10 requests
        const requestsPerSymbol = TIMEFRAMES.length * 2;
        const totalRequests = symbolsCount * requestsPerSymbol;
        
        // If >1000 candles, need multiple API calls per symbol/timeframe
        const apiCallsPerRequest = Math.ceil(candleCount / 1000);
        const adjustedTotalRequests = totalRequests * apiCallsPerRequest;
        const batches = Math.ceil(adjustedTotalRequests / 15);
        
        // More realistic timing: ~500ms per request (including network + processing)
        // Plus 200ms delay between batches (increased to avoid rate limits)
        // Account for rate limiting delays
        const baseTimePerBatch = 500 * 15; // 15 requests × 500ms
        const delayPerBatch = 200;
        const rateLimitDelays = Math.floor(batches / 10) * 2000; // Extra delay every 10 batches
        
        const estimatedMs = (batches * (baseTimePerBatch + delayPerBatch)) + rateLimitDelays;
        const estimatedSeconds = Math.ceil(estimatedMs / 1000);
        const minutes = Math.floor(estimatedSeconds / 60);
        const seconds = estimatedSeconds % 60;
        
        if (minutes > 0) {
          return `${minutes}m ${seconds}s`;
        }
        return `${seconds}s`;
      }

      async fetchHistoricalData(candleCount) {
        if (!this.state.initialized || this.state.symbols.length === 0) {
          alert('Please initialize scanner first');
          return;
        }
        
        const count = parseInt(candleCount);
        if (isNaN(count) || count < 1 || count > 5000) {
          alert('Candle count must be between 1 and 5000');
          return;
        }
        
        this.state.loading = true;
        this.state.progress = { current: 0, total: 0, message: 'Preparing to fetch historical data...', startTime: Date.now(), elapsedTime: 0 };
        this.state.showFetchDialog = false;
        
        // Start timer
        const timerInterval = setInterval(() => {
          if (this.state.loading && this.state.progress.startTime) {
            this.state.progress.elapsedTime = Math.floor((Date.now() - this.state.progress.startTime) / 1000);
            this.render();
          } else {
            clearInterval(timerInterval);
          }
        }, 1000);
        
        this.render();

        try {
          const extremesData = await storage.get('vercel-scanner-extremes');
          let extremesDB = extremesData ? JSON.parse(extremesData.value) : {};
          
          // Ensure structure exists for all symbols
          this.state.symbols.forEach(symbol => {
            if (!extremesDB[symbol]) {
              extremesDB[symbol] = {};
            }
            TIMEFRAMES.forEach(tf => {
              if (!extremesDB[symbol][tf]) {
                extremesDB[symbol][tf] = {
                  volume: { top50: [] },
                  candleSize: { top50: [] }
                };
              }
            });
          });

          // Calculate total requests needed
          // If count > 1000, we need multiple API calls per symbol/timeframe
          const requestsPerSymbolTf = Math.ceil(count / 1000);
          const totalRequests = this.state.symbols.length * TIMEFRAMES.length * 2 * requestsPerSymbolTf;
          this.state.progress.total = totalRequests;
          this.state.progress.message = `Fetching ${count} candles per timeframe for ${this.state.symbols.length} symbols (${totalRequests} API requests)...`;
          this.render();

          const fetchData = {};

          // Fetch volume and candle data in batches of 15
          for (let i = 0; i < this.state.symbols.length; i += 15) {
            const batch = this.state.symbols.slice(i, i + 15);
            
            await Promise.all(batch.map(async (symbol) => {
              if (!extremesDB[symbol]) extremesDB[symbol] = {};
              
                  for (const tf of TIMEFRAMES) {
                try {
                  this.state.progress.message = `Fetching ${symbol} ${tf} (${count} candles)...`;
                  this.render();
                  
                  // Fetch multiple batches if count > 1000
                  let allKlines = [];
                  const batchesNeeded = Math.ceil(count / 1000);
                  
                  for (let batchNum = 0; batchNum < batchesNeeded; batchNum++) {
                    const limit = batchNum === batchesNeeded - 1 ? (count % 1000 || count) : Math.min(1000, count);
                    const endTime = batchNum === 0 ? undefined : allKlines[0] ? allKlines[0][0] - 1 : undefined;
                    
                    let url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${tf}&limit=${limit}`;
                    if (endTime) {
                      url += `&endTime=${endTime}`;
                    }
                    
                    const klines = await fetchWithRetry(url);
                    if (Array.isArray(klines) && klines.length > 0) {
                      allKlines = [...klines, ...allKlines];
                    }
                    
                    // Small delay between batches
                    if (batchNum < batchesNeeded - 1) {
                      await new Promise(resolve => setTimeout(resolve, 100));
                    }
                  }
                  
                  const klines = allKlines.slice(0, count);

                  if (!Array.isArray(klines) || klines.length === 0) {
                    console.warn(`No klines data for ${symbol} ${tf}`);
                    this.state.progress.current++;
                    this.render();
                    continue;
                  }

                  const processed = klines.map(k => ({
                    time: k[0],
                    volume: parseFloat(k[5]),
                    candleSize: ((parseFloat(k[2]) - parseFloat(k[3])) / parseFloat(k[3])) * 100
                  }));

                  const volumeSorted = [...processed].sort((a, b) => b.volume - a.volume);
                  const candleSorted = [...processed].sort((a, b) => b.candleSize - a.candleSize);

                  const existingVol = extremesDB[symbol][tf]?.volume?.top50 || [];
                  const existingCandle = extremesDB[symbol][tf]?.candleSize?.top50 || [];
                  
                  const mergedVol = [...existingVol, ...volumeSorted].sort((a, b) => b.volume - a.volume).slice(0, 50);
                  const mergedCandle = [...existingCandle, ...candleSorted].sort((a, b) => b.candleSize - a.candleSize).slice(0, 50);

                  extremesDB[symbol][tf] = {
                    volume: { top50: mergedVol },
                    candleSize: { top50: mergedCandle }
                  };

                  if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
                  if (!this.timestamps[symbol][tf]) this.timestamps[symbol][tf] = {};
                  
                  const oldestTime = new Date(processed[0].time);
                  const newestTime = new Date(processed[processed.length - 1].time);
                  
                  if (!this.timestamps[symbol][tf].volume) {
                    this.timestamps[symbol][tf].volume = {
                      oldest: oldestTime.toISOString(),
                      lastUpdate: newestTime.toISOString()
                    };
                  } else {
                    const existingOldest = new Date(this.timestamps[symbol][tf].volume.oldest);
                    this.timestamps[symbol][tf].volume.oldest = oldestTime < existingOldest ? oldestTime.toISOString() : this.timestamps[symbol][tf].volume.oldest;
                    this.timestamps[symbol][tf].volume.lastUpdate = newestTime.toISOString();
                  }
                  
                  if (!this.timestamps[symbol][tf].candle) {
                    this.timestamps[symbol][tf].candle = {
                      oldest: oldestTime.toISOString(),
                      lastUpdate: newestTime.toISOString()
                    };
                  } else {
                    const existingOldest = new Date(this.timestamps[symbol][tf].candle.oldest);
                    this.timestamps[symbol][tf].candle.oldest = oldestTime < existingOldest ? oldestTime.toISOString() : this.timestamps[symbol][tf].candle.oldest;
                    this.timestamps[symbol][tf].candle.lastUpdate = newestTime.toISOString();
                  }

                  fetchData[`${symbol}_${tf}`] = new Date().toISOString();
                  
                  // Save incrementally every 50 progress updates to make data visible during fetch
                  if (this.state.progress.current % 50 === 0) {
                    await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
                    await storage.set('vercel-scanner-timestamps', JSON.stringify(this.timestamps));
                  }
                  
                  this.state.progress.current++;
                  this.render();
                } catch (error) {
                  console.error(`Error fetching ${symbol} ${tf}:`, error);
                  this.state.progress.current++;
                  this.render();
                }
              }
            }));
            
            // Save after each batch to ensure data is persisted
            await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
            await storage.set('vercel-scanner-timestamps', JSON.stringify(this.timestamps));
            
            // Delay between batches to respect rate limits (increased to avoid 429 errors)
            if (i + 15 < this.state.symbols.length) {
              await new Promise(resolve => setTimeout(resolve, 200));
            }
          }

          // Fetch historical OI data in batches of 15
          for (let i = 0; i < this.state.symbols.length; i += 15) {
            const batch = this.state.symbols.slice(i, i + 15);
            
            await Promise.all(batch.map(async (symbol) => {
              for (const tf of TIMEFRAMES) {
                try {
                  this.state.progress.message = `Fetching ${symbol} ${tf} (OI)...`;
                  this.render();
                  
                  const periodMap = { '15m': '15m', '1h': '1h', '4h': '4h', '12h': '12h', '1d': '1d' };
                  const period = periodMap[tf];
                  
                  // Fetch multiple batches if count > 1000
                  let allOIData = [];
                  const batchesNeeded = Math.ceil(count / 1000);
                  
                  for (let batchNum = 0; batchNum < batchesNeeded; batchNum++) {
                    const limit = batchNum === batchesNeeded - 1 ? (count % 1000 || count) : Math.min(1000, count);
                    const endTime = batchNum === 0 ? undefined : allOIData[0] ? (allOIData[0].timestamp || allOIData[0].time) - 1 : undefined;
                    
                    let url = `https://fapi.binance.com/fapi/v1/openInterestHist?symbol=${symbol}&period=${period}&limit=${limit}`;
                    if (endTime) {
                      url += `&endTime=${endTime}`;
                    }
                    
                    try {
                      const oiData = await fetchWithRetry(url, 2, 2000, true); // Skip on CORS/404 errors
                      if (oiData && Array.isArray(oiData) && oiData.length > 0) {
                        allOIData = [...oiData, ...allOIData];
                      }
                    } catch (error) {
                      // Silently skip OI if it fails (CORS, 404, etc.)
                      console.log(`Skipping OI for ${symbol} ${tf}: ${error.message}`);
                    }
                    
                    // Small delay between batches
                    if (batchNum < batchesNeeded - 1) {
                      await new Promise(resolve => setTimeout(resolve, 100));
                    }
                  }
                  
                  const oiData = allOIData.slice(0, count);

                  if (!Array.isArray(oiData) || oiData.length < 2) {
                    this.state.progress.current++;
                    this.render();
                    continue;
                  }

                  if (!this.oiHistory[symbol]) this.oiHistory[symbol] = {};
                  if (!this.oiHistory[symbol][tf]) {
                    this.oiHistory[symbol][tf] = {
                      top50Positive: [],
                      top50Negative: []
                    };
                  }

                  // Calculate OI changes from historical data
                  for (let j = 1; j < oiData.length; j++) {
                    const prev = oiData[j - 1];
                    const curr = oiData[j];
                    const prevOI = parseFloat(prev.sumOpenInterest || prev.openInterest || 0);
                    const currOI = parseFloat(curr.sumOpenInterest || curr.openInterest || 0);
                    
                    if (prevOI > 0) {
                      const oiChangePercent = ((currOI - prevOI) / prevOI) * 100;
                      
                      const change = {
                        usdt: currOI,
                        coin: parseFloat(curr.sumOpenInterestValue || 0),
                        percent: oiChangePercent,
                        timestamp: new Date(curr.timestamp || curr.time).toISOString()
                      };
                      
                      if (oiChangePercent > 0) {
                        this.oiHistory[symbol][tf].top50Positive.push(change);
                      } else if (oiChangePercent < 0) {
                        this.oiHistory[symbol][tf].top50Negative.push(change);
                      }
                    }
                  }
                  
                  // Sort and keep top 50
                  this.oiHistory[symbol][tf].top50Positive.sort((a, b) => b.percent - a.percent);
                  this.oiHistory[symbol][tf].top50Positive = this.oiHistory[symbol][tf].top50Positive.slice(0, 50);
                  
                  this.oiHistory[symbol][tf].top50Negative.sort((a, b) => a.percent - b.percent);
                  this.oiHistory[symbol][tf].top50Negative = this.oiHistory[symbol][tf].top50Negative.slice(0, 50);
                  
                  // Update timestamps
                  if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
                  if (!this.timestamps[symbol][tf]) this.timestamps[symbol][tf] = {};
                  
                  const oldestOI = oiData[0];
                  const newestOI = oiData[oiData.length - 1];
                  const oldestTime = new Date(oldestOI.timestamp || oldestOI.time);
                  const newestTime = new Date(newestOI.timestamp || newestOI.time);
                  
                  if (!this.timestamps[symbol][tf].oi) {
                    this.timestamps[symbol][tf].oi = {
                      oldest: oldestTime.toISOString(),
                      lastUpdate: newestTime.toISOString()
                    };
                  } else {
                    const existingOldest = new Date(this.timestamps[symbol][tf].oi.oldest);
                    this.timestamps[symbol][tf].oi.oldest = oldestTime < existingOldest ? oldestTime.toISOString() : this.timestamps[symbol][tf].oi.oldest;
                    this.timestamps[symbol][tf].oi.lastUpdate = newestTime.toISOString();
                  }

                  fetchData[`${symbol}_${tf}_oi`] = new Date().toISOString();
                  this.state.progress.current++;
                  this.render();
                } catch (error) {
                  console.error(`Error fetching OI for ${symbol} ${tf}:`, error);
                  this.state.progress.current++;
                  this.render();
                }
              }
            }));
            
            // Delay between batches to respect rate limits (increased to avoid 429 errors)
            if (i + 15 < this.state.symbols.length) {
              await new Promise(resolve => setTimeout(resolve, 200));
            }
          }

          // Final save
          await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
          await storage.set('vercel-scanner-timestamps', JSON.stringify(this.timestamps));
          await storage.set('vercel-scanner-init', JSON.stringify({
            initialized: true,
            lastFetch: { ...this.state.lastFetch, ...fetchData },
            symbols: this.state.symbols
          }));

          this.state.lastFetch = { ...this.state.lastFetch, ...fetchData };
          const totalTime = this.state.progress.startTime ? Math.floor((Date.now() - this.state.progress.startTime) / 1000) : 0;
          this.state.loading = false;
          
          this.updateTimestampCache();
          await this.saveAllData();
          
          this.render();
          const minutes = Math.floor(totalTime / 60);
          const seconds = totalTime % 60;
          alert(`Historical data fetched successfully! Total time: ${minutes}m ${seconds}s`);
        } catch (error) {
          console.error('Fetch historical data error:', error);
          alert('Error: ' + error.message);
          this.state.loading = false;
          this.render();
        }
      }

      startLiveMonitoring(symbolsList) {
        this.wsRefs.forEach(ws => ws.close());
        this.wsRefs = [];

        const streams = [];
        symbolsList.slice(0, 200).forEach(symbol => {
          TIMEFRAMES.forEach(tf => streams.push(`${symbol.toLowerCase()}@kline_${tf}`));
        });

        const ws = new WebSocket(`wss://fstream.binance.com/stream?streams=${streams.join('/')}`);
        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          if (data.data && data.data.k && data.data.k.x) this.processCandle(data.data);
        };
        this.wsRefs.push(ws);
      }

      async processCandle(klineData) {
        const { s: symbol, k } = klineData;
        const { i: interval, h: high, l: low, v: volume, T: closeTime } = k;
        const candleSize = ((parseFloat(high) - parseFloat(low)) / parseFloat(low)) * 100;
        const vol = parseFloat(volume);

        const extremesData = await storage.get('vercel-scanner-extremes');
        if (!extremesData) return;

        const extremesDB = JSON.parse(extremesData.value);
        if (!extremesDB[symbol] || !extremesDB[symbol][interval]) return;

        const extremes = extremesDB[symbol][interval];

        if (vol > 0 && extremes.volume.top50.length > 0) {
          const top50Vol = extremes.volume.top50;
          if (top50Vol.length < 50 || vol > top50Vol[top50Vol.length - 1].volume) {
            const newEntry = { time: closeTime, volume: vol };
            const merged = [...top50Vol, newEntry].sort((a, b) => b.volume - a.volume).slice(0, 50);
            extremesDB[symbol][interval].volume.top50 = merged;
            await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
            
            if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
            if (!this.timestamps[symbol][interval]) this.timestamps[symbol][interval] = {};
            if (!this.timestamps[symbol][interval].volume) {
              this.timestamps[symbol][interval].volume = { oldest: new Date(closeTime).toISOString(), lastUpdate: new Date(closeTime).toISOString() };
            } else {
              this.timestamps[symbol][interval].volume.lastUpdate = new Date(closeTime).toISOString();
            }
            
            const rank = merged.findIndex(v => v.time === closeTime) + 1;
            if (rank <= 5) {
              this.addAlert(ALERT_FEEDS.find(f => f.timeframes.includes(interval))?.id, {
                symbol,
                type: 'volume',
                subtype: `Top 5 Volume: #${rank}`,
                value: vol.toFixed(2),
                timeframe: interval,
                timestamp: new Date(closeTime)
              });
            }
          }
        }

        if (candleSize > 0 && extremes.candleSize.top50.length > 0) {
          const top50Candle = extremes.candleSize.top50;
          if (top50Candle.length < 50 || candleSize > top50Candle[top50Candle.length - 1].candleSize) {
            const newEntry = { time: closeTime, candleSize: candleSize };
            const merged = [...top50Candle, newEntry].sort((a, b) => b.candleSize - a.candleSize).slice(0, 50);
            extremesDB[symbol][interval].candleSize.top50 = merged;
            await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
            
            if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
            if (!this.timestamps[symbol][interval]) this.timestamps[symbol][interval] = {};
            if (!this.timestamps[symbol][interval].candle) {
              this.timestamps[symbol][interval].candle = { oldest: new Date(closeTime).toISOString(), lastUpdate: new Date(closeTime).toISOString() };
            } else {
              this.timestamps[symbol][interval].candle.lastUpdate = new Date(closeTime).toISOString();
            }
            
            const rank = merged.findIndex(c => c.time === closeTime) + 1;
            if (rank <= 5) {
              this.addAlert(ALERT_FEEDS.find(f => f.timeframes.includes(interval))?.id, {
                symbol,
                type: 'candleSize',
                subtype: `Top 5 Candle Size: #${rank}`,
                value: candleSize.toFixed(2) + '%',
                timeframe: interval,
                timestamp: new Date(closeTime)
              });
            }
          }
        }
        
        this.updateTimestampCache();
        await this.saveAllData();
      }

      addAlert(feedId, alert) {
        if (!feedId || this.state.pausedFeeds[feedId]) return;
        this.state.alerts[feedId] = [alert, ...this.state.alerts[feedId]].slice(0, 100);
        this.audioEl.play().catch(e => console.log('Audio play failed'));
        this.render();
      }

      toggleFeedPause(feedId) {
        this.state.pausedFeeds[feedId] = !this.state.pausedFeeds[feedId];
        this.render();
      }

      toggleExplorer() {
        this.state.showExplorer = !this.state.showExplorer;
        this.render();
      }

      selectSymbol(symbol) {
        this.state.selectedSymbol = symbol;
        this.render();
      }

      setTimeFilter(filter) {
        this.state.timeFilter = filter;
        this.render();
      }

      updateCoinSearch(value) {
        this.state.coinSearch = value;
        this.render();
      }

      formatTimeAgo(dateStr) {
        if (!dateStr) return 'N/A';
        const date = new Date(dateStr);
        const now = new Date();
        const diffMs = now - date;
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffHours / 24);
        
        if (diffDays > 0) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        if (diffHours > 0) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        return 'Just now';
      }

      formatDate(dateStr) {
        if (!dateStr) return 'N/A';
        return new Date(dateStr).toLocaleDateString();
      }

      filterDataByTime(data, timeFilter) {
        if (timeFilter === 'all') return data;
        
        const now = new Date();
        let cutoffDate;
        
        if (timeFilter === '30d') {
          cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        } else if (timeFilter === 'month') {
          cutoffDate = new Date(now.getFullYear(), now.getMonth(), 1);
        } else if (timeFilter === '7d') {
          cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        }
        
        return data.filter(item => {
          const itemDate = new Date(item.timestamp || item.time);
          return itemDate >= cutoffDate;
        });
      }

      getExplorerData() {
        if (!this.state.selectedSymbol) return null;
        
        const symbol = this.state.selectedSymbol;
        let extremesDB = {};
        
        try {
          const stored = localStorage.getItem('vercel-scanner-extremes');
          if (stored) extremesDB = JSON.parse(stored);
        } catch (e) {
          console.error('Error reading extremes from localStorage:', e);
        }
        
        // Ensure oiHistory is initialized
        if (!this.oiHistory) this.oiHistory = {};
        
        const data = {
          symbol,
          timeframes: {}
        };
        
        TIMEFRAMES.forEach(tf => {
          const volData = extremesDB[symbol]?.[tf]?.volume?.top50 || [];
          const candleData = extremesDB[symbol]?.[tf]?.candleSize?.top50 || [];
          const oiPosData = (this.oiHistory[symbol] && this.oiHistory[symbol][tf]) ? (this.oiHistory[symbol][tf].top50Positive || []) : [];
          const oiNegData = (this.oiHistory[symbol] && this.oiHistory[symbol][tf]) ? (this.oiHistory[symbol][tf].top50Negative || []) : [];
          
          // Filter by time
          const filteredVol = this.filterDataByTime(volData, this.state.timeFilter);
          const filteredCandle = this.filterDataByTime(candleData, this.state.timeFilter);
          const filteredOIPos = this.filterDataByTime(oiPosData, this.state.timeFilter);
          const filteredOINeg = this.filterDataByTime(oiNegData, this.state.timeFilter);
          
          // Sort and take top 5
          const top5Vol = [...filteredVol].sort((a, b) => b.volume - a.volume).slice(0, 5);
          const top5Candle = [...filteredCandle].sort((a, b) => b.candleSize - a.candleSize).slice(0, 5);
          const top5OIPos = [...filteredOIPos].sort((a, b) => b.percent - a.percent).slice(0, 5);
          const top5OINeg = [...filteredOINeg].sort((a, b) => a.percent - b.percent).slice(0, 5);
          
          data.timeframes[tf] = {
            volume: top5Vol,
            candleSize: top5Candle,
            oiPositive: top5OIPos,
            oiNegative: top5OINeg
          };
        });
        
        console.log('getExplorerData - Final data:', data);
        return data;
      }

      getFilteredSymbols() {
        const search = this.state.coinSearch.toLowerCase();
        return this.state.symbols.filter(sym => {
          const baseSymbol = sym.replace('USDT', '');
          return baseSymbol.toLowerCase().includes(search) || sym.toLowerCase().includes(search);
        });
      }

      render() {
        const root = document.getElementById('root');
        const s = this.state;
        
        const getInfoTooltip = () => {
          if (!this.timestampCache || Object.keys(this.timestampCache).length === 0) {
            return '<div class="text-gray-400 text-sm">No data available</div>';
          }
          
          let html = '<div class="space-y-2 text-sm">';
          TIMEFRAMES.forEach(tf => {
            ['volume', 'candle', 'oi'].forEach(metric => {
              const key = `${tf}_${metric}`;
              const cache = this.timestampCache[key];
              if (cache) {
                const metricName = metric === 'candle' ? 'CANDLE SIZE%' : metric.toUpperCase();
                const oldestMin = new Date(cache.oldestMin);
                const oldestMax = new Date(cache.oldestMax);
                const lastUpdate = new Date(cache.lastUpdateMin);
                
                const oldestMinStr = oldestMin.toLocaleDateString();
                const oldestMaxStr = oldestMax.toLocaleDateString();
                const oldestRange = oldestMinStr === oldestMaxStr 
                  ? oldestMinStr 
                  : `${oldestMinStr} (${cache.oldestMinCoin}) - ${oldestMaxStr} (${cache.oldestMaxCoin})`;
                
                html += `
                  <div class="border-b border-gray-700 pb-2">
                    <div class="font-semibold text-yellow-400">${tf.toUpperCase()} ${metricName}</div>
                    <div class="text-gray-300">Oldest: ${oldestRange}</div>
                    <div class="text-gray-300">Last updated: ${this.formatDate(cache.lastUpdateMin)} (${this.formatTimeAgo(cache.lastUpdateMin)})</div>
                  </div>
                `;
              }
            });
          });
          html += '</div>';
          return html;
        };
        
        const filteredSymbols = this.getFilteredSymbols();
        
        const tzDisplay = this.timezone.tzAbbr || `${this.timezone.tz} (${this.timezone.offsetStr})`;
        
        root.innerHTML = `
          <div class="text-xs text-gray-500 mb-2 text-right">Timezone: ${tzDisplay}</div>
          <div class="flex items-center justify-between mb-6">
            <h1 class="text-3xl font-bold">Vercel Scanner</h1>
            <div class="flex items-center gap-4">
              ${s.initialized ? `
                <button onclick="scanner.exportData()" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded">
                  Export Data
                </button>
                <input type="file" id="importFileMain" accept=".json" class="hidden" 
                       onchange="scanner.importData(this.files[0])">
                <label for="importFileMain" class="px-4 py-2 bg-teal-600 hover:bg-teal-700 rounded cursor-pointer">
                  Import Data
                </label>
                <button onclick="scanner.state.showFetchDialog = true; scanner.render()" ${s.loading ? 'disabled' : ''} 
                  class="px-4 py-2 bg-orange-600 hover:bg-orange-700 disabled:bg-gray-600 rounded">
                  Fetch Historical Data
                </button>
                <button onclick="scanner.fillGaps()" ${s.loading ? 'disabled' : ''} 
                  class="px-4 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 rounded">
                  Fill Gaps
                </button>
                <button onclick="scanner.toggleExplorer()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded">
                  ${s.showExplorer ? 'Hide' : 'Show'} Explorer
                </button>
              ` : ''}
              <div class="relative">
                <button onmouseenter="scanner.state.showInfo = true; scanner.render()" 
                        onmouseleave="scanner.state.showInfo = false; scanner.render()"
                        class="p-2 bg-gray-700 hover:bg-gray-600 rounded text-xl">
                  ℹ️
                </button>
                ${s.showInfo ? `
                  <div class="absolute right-0 top-full mt-2 w-96 bg-gray-800 rounded-lg p-4 shadow-xl z-50 border border-gray-700"
                       onmouseenter="scanner.state.showInfo = true"
                       onmouseleave="scanner.state.showInfo = false; scanner.render()">
                    ${getInfoTooltip()}
                  </div>
                ` : ''}
              </div>
            </div>
          </div>

          ${s.showImportPrompt ? `
            <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
              <div class="bg-gray-800 rounded-lg p-6 max-w-md">
                <h2 class="text-xl font-bold mb-4">${s.initialized ? 'Import/Download Data?' : 'Import Existing Data?'}</h2>
                <p class="text-gray-300 mb-4">
                  ${s.initialized 
                    ? 'Do you want to import previously exported data or download current browser data?' 
                    : 'Do you want to import previously exported data before initializing?'}
                </p>
                <div class="flex flex-col gap-3">
                  <input type="file" id="importFile" accept=".json" class="hidden" 
                         onchange="scanner.importData(this.files[0])">
                  <label for="importFile" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded cursor-pointer text-center">
                    Import from File
                  </label>
                  ${s.initialized ? `
                    <button onclick="scanner.exportData(); scanner.state.showImportPrompt = false; scanner.render()" 
                            class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded">
                      Download Current Data
                    </button>
                  ` : ''}
                  <button onclick="scanner.state.showImportPrompt = false; scanner.render()" 
                          class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded">
                    ${s.initialized ? 'Cancel' : 'Skip'}
                  </button>
                </div>
              </div>
            </div>
          ` : ''}

          ${s.showCandlePrompt ? `
            <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
              <div class="bg-gray-800 rounded-lg p-6 max-w-md">
                <h2 class="text-xl font-bold mb-4">Fetch Historical Data?</h2>
                <p class="text-gray-300 mb-4">How many candles per timeframe would you like to fetch? (1-5000)</p>
                <div class="mb-4">
                  <input type="number" id="candleCountInput" value="${s.candleCount}" min="1" max="5000"
                         class="w-full px-4 py-2 bg-gray-700 rounded text-white"
                         oninput="const val = parseInt(this.value); if (!isNaN(val) && val >= 1) { scanner.state.candleCount = val; const estimateEl = document.getElementById('candleEstimate'); if (estimateEl) estimateEl.textContent = 'Current selection: ~' + scanner.calculateTimeEstimate(val, scanner.state.symbols.length || 300); }">
                </div>
                <div class="mb-4 text-xs text-gray-400">
                  <div>Time estimates (${this.state.symbols.length || 300} symbols):</div>
                  <div>• 100 candles: ~${this.calculateTimeEstimate(100, this.state.symbols.length || 300)}</div>
                  <div>• 500 candles: ~${this.calculateTimeEstimate(500, this.state.symbols.length || 300)}</div>
                  <div>• 1000 candles: ~${this.calculateTimeEstimate(1000, this.state.symbols.length || 300)}</div>
                  <div>• 5000 candles: ~${this.calculateTimeEstimate(5000, this.state.symbols.length || 300)}</div>
                  <div id="candleEstimate" class="mt-2 text-yellow-400">Current selection: ~${this.calculateTimeEstimate(s.candleCount || 100, this.state.symbols.length || 300)}</div>
                </div>
                <div class="flex gap-4">
                  <button onclick="scanner.fetchHistoricalData(scanner.state.candleCount); scanner.state.showCandlePrompt = false; scanner.render()" 
                          class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded">
                    Fetch Data
                  </button>
                  <button onclick="scanner.state.showCandlePrompt = false; scanner.render()" 
                          class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded">
                    Skip
                  </button>
                </div>
              </div>
            </div>
          ` : ''}

          ${s.showFetchDialog ? `
            <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
              <div class="bg-gray-800 rounded-lg p-6 max-w-md">
                <h2 class="text-xl font-bold mb-4">Fetch Historical Data</h2>
                <p class="text-gray-300 mb-4">How many candles per timeframe would you like to fetch? (1-5000)</p>
                <div class="mb-4">
                  <input type="number" id="fetchCandleCountInput" value="${s.candleCount}" min="1" max="5000"
                         class="w-full px-4 py-2 bg-gray-700 rounded text-white"
                         oninput="const val = parseInt(this.value); if (!isNaN(val) && val >= 1) { scanner.state.candleCount = val; const estimateEl = document.getElementById('fetchCandleEstimate'); if (estimateEl) estimateEl.textContent = 'Current selection: ~' + scanner.calculateTimeEstimate(val, scanner.state.symbols.length || 300); }">
                </div>
                <div class="mb-4 text-xs text-gray-400">
                  <div>Time estimates (${this.state.symbols.length || 300} symbols):</div>
                  <div>• 100 candles: ~${this.calculateTimeEstimate(100, this.state.symbols.length || 300)}</div>
                  <div>• 500 candles: ~${this.calculateTimeEstimate(500, this.state.symbols.length || 300)}</div>
                  <div>• 1000 candles: ~${this.calculateTimeEstimate(1000, this.state.symbols.length || 300)}</div>
                  <div>• 5000 candles: ~${this.calculateTimeEstimate(5000, this.state.symbols.length || 300)}</div>
                  <div id="fetchCandleEstimate" class="mt-2 text-yellow-400">Current selection: ~${this.calculateTimeEstimate(s.candleCount || 100, this.state.symbols.length || 300)}</div>
                </div>
                <div class="flex gap-4">
                  <button onclick="scanner.fetchHistoricalData(scanner.state.candleCount); scanner.state.showFetchDialog = false; scanner.render()" 
                          class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded">
                    Fetch Data
                  </button>
                  <button onclick="scanner.state.showFetchDialog = false; scanner.render()" 
                          class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded">
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          ` : ''}

          ${s.showDataAvailability ? `
            <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
              <div class="bg-gray-800 rounded-lg p-6 max-w-lg">
                <h2 class="text-xl font-bold mb-4">Data Availability</h2>
                <div class="mb-4 max-h-64 overflow-y-auto">
                  ${(() => {
                    if (!this.timestampCache || Object.keys(this.timestampCache).length === 0) {
                      return '<div class="text-gray-400 text-sm">No historical data available. Would you like to fetch some?</div>';
                    }
                    
                    let html = '<div class="space-y-2 text-sm">';
                    TIMEFRAMES.forEach(tf => {
                      ['volume', 'candle', 'oi'].forEach(metric => {
                        const key = `${tf}_${metric}`;
                        const cache = this.timestampCache[key];
                        if (cache) {
                          const metricName = metric === 'candle' ? 'Candle Size%' : metric.toUpperCase();
                          const oldestMin = new Date(cache.oldestMin);
                          const oldestMax = new Date(cache.oldestMax);
                          const lastUpdate = new Date(cache.lastUpdateMin);
                          
                          const oldestMinStr = oldestMin.toLocaleDateString();
                          const oldestMaxStr = oldestMax.toLocaleDateString();
                          const oldestRange = oldestMinStr === oldestMaxStr 
                            ? oldestMinStr 
                            : `${oldestMinStr} (${cache.oldestMinCoin}) - ${oldestMaxStr} (${cache.oldestMaxCoin})`;
                          
                          html += `
                            <div class="border-b border-gray-700 pb-2">
                              <div class="font-semibold text-yellow-400">${tf.toUpperCase()} ${metricName}</div>
                              <div class="text-gray-300 text-xs">Oldest: ${oldestRange}</div>
                              <div class="text-gray-300 text-xs">Last updated: ${this.formatDate(cache.lastUpdateMin)} (${this.formatTimeAgo(cache.lastUpdateMin)})</div>
                            </div>
                          `;
                        }
                      });
                    });
                    html += '</div>';
                    return html;
                  })()}
                </div>
                <div class="flex gap-4 mt-4">
                  <button onclick="scanner.state.showDataAvailability = false; scanner.state.showFetchDialog = true; scanner.render()" 
                          class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded">
                    Fetch More Data
                  </button>
                  <button onclick="scanner.state.showDataAvailability = false; scanner.render()" 
                          class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded">
                    Continue
                  </button>
                </div>
              </div>
            </div>
          ` : ''}

          ${!s.initialized ? `
            <div class="flex flex-col items-center justify-center mt-20">
              <button onclick="scanner.initializeScanner()" ${s.loading ? 'disabled' : ''} 
                class="px-8 py-4 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded-lg text-lg font-semibold">
                ${s.loading ? 'Initializing...' : 'Initialize Scanner'}
              </button>
              ${s.loading ? `
                <div class="mt-8 w-96 bg-gray-800 rounded-lg p-4">
                  <div class="text-center mb-2">
                    ${s.progress.message || 'Loading...'} ${s.progress.total > 0 ? `${s.progress.current}/${s.progress.total} (${Math.round((s.progress.current / s.progress.total) * 100)}%)` : ''}
                  </div>
                  ${s.progress.total > 0 ? `
                    <div class="w-full bg-gray-700 rounded-full h-4">
                      <div class="bg-blue-600 h-4 rounded-full transition-all" 
                        style="width: ${(s.progress.current / s.progress.total) * 100}%"></div>
                    </div>
                  ` : ''}
                </div>
              ` : ''}
            </div>
          ` : `
            ${s.loading && s.progress.total > 0 ? `
              <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div class="bg-gray-800 rounded-lg p-6 max-w-md">
                  <h2 class="text-xl font-bold mb-4">${s.progress.message || 'Processing...'}</h2>
                  <div class="text-center mb-2">
                    ${s.progress.current}/${s.progress.total} (${Math.round((s.progress.current / s.progress.total) * 100)}%)
                  </div>
                  <div class="w-full bg-gray-700 rounded-full h-4 mb-2">
                    <div class="bg-blue-600 h-4 rounded-full transition-all" 
                      style="width: ${(s.progress.current / s.progress.total) * 100}%"></div>
                  </div>
                  <div class="text-xs text-gray-400 text-center mb-2">
                    Please wait, this may take a few minutes...
                  </div>
                  ${s.progress.startTime ? `
                    <div class="text-xs text-yellow-400 text-center font-semibold">
                      Elapsed time: ${Math.floor((s.progress.elapsedTime || 0) / 60)}m ${(s.progress.elapsedTime || 0) % 60}s
                    </div>
                  ` : ''}
                </div>
              </div>
            ` : ''}
            ${s.showExplorer ? `
              <div class="mb-6 bg-gray-800 rounded-lg p-4">
                <div class="mb-4">
                  <label class="block text-sm font-semibold mb-2">Search & Select Coin:</label>
                  <input type="text" 
                         value="${s.coinSearch}"
                         oninput="scanner.updateCoinSearch(this.value)"
                         placeholder="Type to search (e.g., BTC, ETH)..."
                         class="w-full px-4 py-2 bg-gray-700 rounded text-white mb-2">
                  <select onchange="scanner.selectSymbol(this.value)" 
                          class="w-full px-4 py-2 bg-gray-700 rounded text-white">
                    <option value="">-- Select a coin --</option>
                    ${filteredSymbols.map(sym => {
                      const baseSymbol = sym.replace('USDT', '');
                      return `<option value="${sym}" ${sym === s.selectedSymbol ? 'selected' : ''}>${baseSymbol}</option>`;
                    }).join('')}
                  </select>
                </div>
                ${s.selectedSymbol ? (() => {
                  const explorerData = this.getExplorerData();
                  if (!explorerData) return '<div class="text-gray-400">Loading...</div>';
                  
                  const baseSymbol = explorerData.symbol.replace('USDT', '');
                  
                  return `
                    <div class="space-y-3">
                      <div class="flex items-center justify-between mb-3">
                        <h3 class="text-xl font-bold">${baseSymbol}</h3>
                        <div class="flex gap-2">
                          <button onclick="scanner.setTimeFilter('all')" 
                                  class="px-3 py-1 text-xs ${s.timeFilter === 'all' ? 'bg-blue-600' : 'bg-gray-700'} rounded">
                            All Time
                          </button>
                          <button onclick="scanner.setTimeFilter('30d')" 
                                  class="px-3 py-1 text-xs ${s.timeFilter === '30d' ? 'bg-blue-600' : 'bg-gray-700'} rounded">
                            Last 30 Days
                          </button>
                          <button onclick="scanner.setTimeFilter('month')" 
                                  class="px-3 py-1 text-xs ${s.timeFilter === 'month' ? 'bg-blue-600' : 'bg-gray-700'} rounded">
                            This Month
                          </button>
                          <button onclick="scanner.setTimeFilter('7d')" 
                                  class="px-3 py-1 text-xs ${s.timeFilter === '7d' ? 'bg-blue-600' : 'bg-gray-700'} rounded">
                            Last 7 Days
                          </button>
                        </div>
                      </div>
                      <div class="grid grid-cols-2 gap-3">
                        ${TIMEFRAMES.map(tf => {
                          const tfData = explorerData.timeframes[tf];
                          return `
                            <div class="bg-gray-900 rounded p-3 text-xs">
                              <h4 class="font-semibold text-sm mb-2">${tf}</h4>
                              <div class="grid grid-cols-2 gap-2">
                                <div>
                                  <h5 class="font-semibold text-green-400 mb-1 text-xs">Top 5 OI ↑</h5>
                                  ${tfData.oiPositive.length > 0 ? tfData.oiPositive.map((oi, idx) => `
                                    <div class="text-xs mb-0.5">
                                      #${idx + 1}: ${oi.percent.toFixed(2)}%
                                    </div>
                                  `).join('') : '<div class="text-gray-500 text-xs">No data</div>'}
                                </div>
                                <div>
                                  <h5 class="font-semibold text-red-400 mb-1 text-xs">Top 5 OI ↓</h5>
                                  ${tfData.oiNegative.length > 0 ? tfData.oiNegative.map((oi, idx) => `
                                    <div class="text-xs mb-0.5">
                                      #${idx + 1}: ${oi.percent.toFixed(2)}%
                                    </div>
                                  `).join('') : '<div class="text-gray-500 text-xs">No data</div>'}
                                </div>
                                <div>
                                  <h5 class="font-semibold text-blue-400 mb-1 text-xs">Top 5 Vol</h5>
                                  ${tfData.volume.length > 0 ? tfData.volume.map((vol, idx) => `
                                    <div class="text-xs mb-0.5">
                                      #${idx + 1}: ${vol.volume.toFixed(2)}
                                    </div>
                                  `).join('') : '<div class="text-gray-500 text-xs">No data</div>'}
                                </div>
                                <div>
                                  <h5 class="font-semibold text-yellow-400 mb-1 text-xs">Top 5 Candle%</h5>
                                  ${tfData.candleSize.length > 0 ? tfData.candleSize.map((candle, idx) => `
                                    <div class="text-xs mb-0.5">
                                      #${idx + 1}: ${candle.candleSize.toFixed(2)}%
                                    </div>
                                  `).join('') : '<div class="text-gray-500 text-xs">No data</div>'}
                                </div>
                              </div>
                            </div>
                          `;
                        }).join('')}
                      </div>
                    </div>
                  `;
                })() : '<div class="text-gray-400">Select a coin to view data</div>'}
              </div>
            ` : ''}
            <div class="grid grid-cols-3 gap-4">
              ${ALERT_FEEDS.map(feed => `
                <div class="bg-gray-800 rounded-lg p-4">
                  <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-semibold">${feed.name}</h2>
                    <button onclick="scanner.toggleFeedPause('${feed.id}')" 
                      class="p-2 bg-gray-700 hover:bg-gray-600 rounded">
                      ${s.pausedFeeds[feed.id] ? '▶' : '⏸'}
                    </button>
                  </div>
                  <div class="space-y-2 max-h-[600px] overflow-y-auto">
                    ${s.alerts[feed.id].length === 0 ? `
                      <div class="text-gray-500 text-sm text-center py-8">
                        No alerts yet. Monitoring live...
                      </div>
                    ` : s.alerts[feed.id].map(alert => `
                      <div class="bg-gray-900 rounded p-3 text-sm border-l-4 border-yellow-500">
                        <div class="flex items-start justify-between">
                          <span class="font-bold">${alert.symbol}</span>
                          <span class="text-gray-400 text-xs">${alert.timeframe}</span>
                        </div>
                        <div class="mt-1 text-yellow-400">${alert.subtype}</div>
                        <div class="mt-1 text-gray-300">Value: ${alert.value}</div>
                        <div class="mt-1 text-gray-500 text-xs">
                          ${alert.timestamp.toLocaleString()}
                        </div>
                      </div>
                    `).join('')}
                  </div>
                </div>
              `).join('')}
            </div>
          `}
        `;
      }
    }

    const scanner = new Scanner();
    window.scanner = scanner;
  </script>
</body>
</html>
