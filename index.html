<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vercel Scanner</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-white p-6">
  <div id="root"></div>
  
  <script type="module">
    const TIMEFRAMES = ['15m', '1h', '4h', '12h', '1d'];
    const ALERT_FEEDS = [
      { id: 'feed1', name: '15m + 1h', timeframes: ['15m', '1h'] },
      { id: 'feed2', name: '4h + 12h', timeframes: ['4h', '12h'] },
      { id: 'feed3', name: '1D', timeframes: ['1d'] }
    ];

    const storage = {
      async get(key) {
        try {
          const value = localStorage.getItem(key);
          return value ? { value } : null;
        } catch (e) {
          return null;
        }
      },
      async set(key, value) {
        try {
          localStorage.setItem(key, value);
          return { key, value };
        } catch (e) {
          return null;
        }
      }
    };

    class Scanner {
      constructor() {
        this.state = {
          loading: false,
          progress: { current: 0, total: 0 },
          initialized: false,
          alerts: { feed1: [], feed2: [], feed3: [] },
          pausedFeeds: { feed1: false, feed2: false, feed3: false },
          showInfo: false,
          showExplorer: false,
          selectedSymbol: null,
          lastFetch: {},
          symbols: [],
          showImportPrompt: false
        };
        this.wsRefs = [];
        this.lastOIData = {}; // { symbol: { usdt: number, coin: number } }
        this.oiHistory = {}; // { symbol: { timeframe: { changes: [...], top5Positive: [...], top5Negative: [...] } } }
        this.timestamps = {}; // { symbol: { timeframe: { volume: { oldest: date, lastUpdate: date }, candle: {...}, oi: {...} } } }
        this.timestampCache = {}; // Cached aggregates for fast tooltip access
        this.audioEl = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIGGS78OScTgwOTqXh8LdjHAU2jNXxzn0vBSh+zPDaklALFF7A7+mlVRIIQ5zd8sFuIwUqgM3y2Ik3CBhju+/gnE4MDU6l4fC3YxwFOIzV8c59LwUofszw2pJQCxNewO/ppVUSCEOc3fLBbiMFKoDN8tmJNwgYY7vv4JxODA1OpeHwt2McBTiM1fHOfS8FKH7M8NqSUAsUXsDv6aVVEghDnN3ywW4jBSqAzfLZiTcIGGO77+CcTgwNTqXh8LdjHAU4jNXxzn0vBSh+zPDaklALFF7A7+mlVRIIQ5zd8sFuIwUqgM3y2Yk3CBhju+/gnE4MDU6l4fC3YxwFOIzV8c59LwUofszw2pJQCxRewO/ppVUSCEOc3fLBbiMFKoDN8tmJNwgYY7vv4JxODA1OpeHwt2McBTiM1fHOfS8FKH7M8NqSUAsUXsDv6aVVEghDnN3ywW4jBSqAzfLZiTcIGGO77+CcTgwNTqXh8LdjHAU4jNXxzn0vBSh+zPDaklALFF7A7+mlVRIIQ5zd8sFuIwUqgM3y2Yk3CBhju+/gnE4MDU6l4fC3YxwFOIzV8c59LwUofszw2pJQCxRewO/ppVUSCEOc3fLBbiMFKoDN8tmJNwgYY7vv4JxODA1OpeHwt2McBTiM1fHOfS8FKH7M8NqSUAsUXsDv6aVVEghDnN3ywW4jBSqAzfLZiTcIGGO77+CcTgwNTqXh8LdjHAU4jNXxzn0vBSh+zPDaklALFF7A7+mlVRIIQ5zd8sFuIwUqgM3y2Yk3CBhju+/gnE4MDU6l4fC3YxwFOIzV8c59LwUofszw2pJQCxRewO/ppVUSCEOc3fLBbiMFKoDN8tmJNwgYY7vv4JxODA1OpeHwt2McBTiM1fHOfS8FKH7M8NqSUAsUXsDv6aVVEghDnN3ywW4jBSqAzfLZiTcIGGO77+CcTgwNTqXh8LdjHAU4jNXxzn0vBSh+zPDaklALFF7A7+mlVRIIQ5zd8sFuIwUqgM3y2Yk3CBhju+/gnE4MDU6l4fC3YxwFOIzV8c59LwUofszw2pJQCxRewO/ppVUSCEOc3fLBbiMFKoDN8tmJNwgYY7vv4JxODA1OpeHwt2McBTiM1fHOfS8FKH7M8NqSUAsUXsDv6aVVEghDnN3ywW4jBSqAzfLZiTcIGGO77+CcTgwNTqXh8LdjHAU4jNXxzn0vBSh+zPDaklALFF7A7+mlVRIIQ5zd8sFuIwUqgM3y');
        this.init();
      }

      async init() {
        await this.loadStoredData();
        // Always ask if user wants to import data
        if (!this.state.initialized) {
          this.state.showImportPrompt = true;
        }
        this.render();
        if (this.state.initialized && this.state.symbols.length > 0) {
          this.startOIPolling();
        }
      }

      async loadStoredData() {
        try {
          const stored = await storage.get('vercel-scanner-init');
          if (stored) {
            const data = JSON.parse(stored.value);
            this.state.initialized = data.initialized;
            this.state.lastFetch = data.lastFetch || {};
            this.state.symbols = data.symbols || [];
          }
          
          // Load OI history
          const oiData = await storage.get('vercel-scanner-oi');
          if (oiData) {
            this.oiHistory = JSON.parse(oiData.value);
          }
          
          // Load timestamps
          const tsData = await storage.get('vercel-scanner-timestamps');
          if (tsData) {
            this.timestamps = JSON.parse(tsData.value);
          }
          
          // Load timestamp cache
          const cacheData = await storage.get('vercel-scanner-timestamp-cache');
          if (cacheData) {
            this.timestampCache = JSON.parse(cacheData.value);
          }
          
          // Load last OI data
          const lastOIData = await storage.get('vercel-scanner-last-oi');
          if (lastOIData) {
            this.lastOIData = JSON.parse(lastOIData.value);
          }
        } catch (error) {
          console.log('No stored data found');
        }
      }

      async saveAllData() {
        await storage.set('vercel-scanner-oi', JSON.stringify(this.oiHistory));
        await storage.set('vercel-scanner-timestamps', JSON.stringify(this.timestamps));
        await storage.set('vercel-scanner-timestamp-cache', JSON.stringify(this.timestampCache));
        await storage.set('vercel-scanner-last-oi', JSON.stringify(this.lastOIData));
      }

      updateTimestampCache() {
        // Recalculate aggregates from per-coin timestamps
        const cache = {};
        
        TIMEFRAMES.forEach(tf => {
          ['volume', 'candle', 'oi'].forEach(metric => {
            const key = `${tf}_${metric}`;
            let oldestMin = null, oldestMax = null, lastUpdateMin = null;
            let oldestMinCoin = null, oldestMaxCoin = null;
            
            Object.keys(this.timestamps).forEach(symbol => {
              if (this.timestamps[symbol][tf] && this.timestamps[symbol][tf][metric]) {
                const ts = this.timestamps[symbol][tf][metric];
                const oldest = new Date(ts.oldest);
                const lastUpdate = new Date(ts.lastUpdate);
                
                if (!oldestMin || oldest < oldestMin) {
                  oldestMin = oldest;
                  oldestMinCoin = symbol;
                }
                if (!oldestMax || oldest > oldestMax) {
                  oldestMax = oldest;
                  oldestMaxCoin = symbol;
                }
                if (!lastUpdateMin || lastUpdate < lastUpdateMin) {
                  lastUpdateMin = lastUpdate;
                }
              }
            });
            
            if (oldestMin) {
              cache[key] = {
                oldestMin: oldestMin.toISOString(),
                oldestMax: oldestMax.toISOString(),
                oldestMinCoin,
                oldestMaxCoin,
                lastUpdateMin: lastUpdateMin.toISOString()
              };
            }
          });
        });
        
        this.timestampCache = cache;
      }

      startOIPolling() {
        setInterval(() => this.pollOpenInterest(), 300000);
        this.pollOpenInterest();
      }

      async pollOpenInterest() {
        if (!this.state.symbols || this.state.symbols.length === 0) return;
        
        for (const symbol of this.state.symbols.slice(0, 50)) {
          try {
            await new Promise(resolve => setTimeout(resolve, 100));
            const response = await fetch(`https://fapi.binance.com/fapi/v1/openInterest?symbol=${symbol}`);
            const data = await response.json();
            
            if (data.openInterest) {
              const currentOIUsdt = parseFloat(data.openInterest);
              // For coin value, we need to get price and calculate, or use sumOpenInterest if available
              // Binance current OI endpoint returns openInterest in USDT
              // We'll calculate coin value from price if sumOpenInterest not available
              let currentOICoin = data.sumOpenInterest ? parseFloat(data.sumOpenInterest) : null;
              
              // If sumOpenInterest not available, we'll fetch price to calculate
              if (!currentOICoin) {
                try {
                  const priceResponse = await fetch(`https://fapi.binance.com/fapi/v1/ticker/price?symbol=${symbol}`);
                  const priceData = await priceResponse.json();
                  if (priceData.price) {
                    currentOICoin = currentOIUsdt / parseFloat(priceData.price);
                  }
                } catch (e) {
                  console.error(`Error fetching price for ${symbol}:`, e);
                  currentOICoin = 0;
                }
              }
              const prevOI = this.lastOIData[symbol];
              
              if (prevOI && prevOI.usdt > 0) {
                const oiChangePercent = ((currentOIUsdt - prevOI.usdt) / prevOI.usdt) * 100;
                
                // Store OI change for each timeframe (using same timeframes)
                TIMEFRAMES.forEach(tf => {
                  if (!this.oiHistory[symbol]) this.oiHistory[symbol] = {};
                  if (!this.oiHistory[symbol][tf]) {
                    this.oiHistory[symbol][tf] = {
                      changes: [],
                      top5Positive: [],
                      top5Negative: []
                    };
                  }
                  
                  const change = {
                    usdt: currentOIUsdt,
                    coin: currentOICoin,
                    percent: oiChangePercent,
                    timestamp: new Date().toISOString()
                  };
                  
                  this.oiHistory[symbol][tf].changes.push(change);
                  
                  // Update top 5 positive
                  if (oiChangePercent > 0) {
                    this.oiHistory[symbol][tf].top5Positive.push(change);
                    this.oiHistory[symbol][tf].top5Positive.sort((a, b) => b.percent - a.percent);
                    this.oiHistory[symbol][tf].top5Positive = this.oiHistory[symbol][tf].top5Positive.slice(0, 5);
                  }
                  
                  // Update top 5 negative
                  if (oiChangePercent < 0) {
                    this.oiHistory[symbol][tf].top5Negative.push(change);
                    this.oiHistory[symbol][tf].top5Negative.sort((a, b) => a.percent - b.percent);
                    this.oiHistory[symbol][tf].top5Negative = this.oiHistory[symbol][tf].top5Negative.slice(0, 5);
                  }
                  
                  // Update timestamp
                  if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
                  if (!this.timestamps[symbol][tf]) this.timestamps[symbol][tf] = {};
                  if (!this.timestamps[symbol][tf].oi) {
                    this.timestamps[symbol][tf].oi = { oldest: change.timestamp, lastUpdate: change.timestamp };
                  } else {
                    this.timestamps[symbol][tf].oi.lastUpdate = change.timestamp;
                  }
                });
                
                if (Math.abs(oiChangePercent) > 5) {
                  this.addAlert('feed1', {
                    symbol,
                    type: 'oiChange',
                    subtype: 'Significant OI Change',
                    value: oiChangePercent.toFixed(2) + '%',
                    timeframe: '5m',
                    timestamp: new Date()
                  });
                }
              }
              
              this.lastOIData[symbol] = { usdt: currentOIUsdt, coin: currentOICoin || 0 };
            }
          } catch (error) {
            console.error(`Error polling OI for ${symbol}:`, error);
          }
        }
        
        this.updateTimestampCache();
        await this.saveAllData();
      }

      async importData(file) {
        try {
          const text = await file.text();
          const data = JSON.parse(text);
          
          // Merge extremes data
          if (data.extremes) {
            const currentExtremes = await storage.get('vercel-scanner-extremes');
            let extremesDB = currentExtremes ? JSON.parse(currentExtremes.value) : {};
            
            Object.keys(data.extremes).forEach(symbol => {
              if (!extremesDB[symbol]) extremesDB[symbol] = {};
              Object.keys(data.extremes[symbol]).forEach(tf => {
                if (!extremesDB[symbol][tf]) extremesDB[symbol][tf] = { volume: { top5: [] }, candleSize: { top5: [] } };
                
                // Merge volume top5
                const mergedVol = [...(extremesDB[symbol][tf].volume.top5 || []), ...(data.extremes[symbol][tf].volume.top5 || [])];
                mergedVol.sort((a, b) => b.volume - a.volume);
                extremesDB[symbol][tf].volume.top5 = mergedVol.slice(0, 5);
                
                // Merge candle top5
                const mergedCandle = [...(extremesDB[symbol][tf].candleSize.top5 || []), ...(data.extremes[symbol][tf].candleSize.top5 || [])];
                mergedCandle.sort((a, b) => b.candleSize - a.candleSize);
                extremesDB[symbol][tf].candleSize.top5 = mergedCandle.slice(0, 5);
              });
            });
            
            await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
          }
          
          // Merge OI history
          if (data.oiHistory) {
            Object.keys(data.oiHistory).forEach(symbol => {
              if (!this.oiHistory[symbol]) this.oiHistory[symbol] = {};
              Object.keys(data.oiHistory[symbol]).forEach(tf => {
                if (!this.oiHistory[symbol][tf]) {
                  this.oiHistory[symbol][tf] = { changes: [], top5Positive: [], top5Negative: [] };
                }
                
                // Merge changes
                this.oiHistory[symbol][tf].changes = [...this.oiHistory[symbol][tf].changes, ...(data.oiHistory[symbol][tf].changes || [])];
                this.oiHistory[symbol][tf].changes.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                // Recalculate top5
                const positives = this.oiHistory[symbol][tf].changes.filter(c => c.percent > 0).sort((a, b) => b.percent - a.percent).slice(0, 5);
                const negatives = this.oiHistory[symbol][tf].changes.filter(c => c.percent < 0).sort((a, b) => a.percent - b.percent).slice(0, 5);
                this.oiHistory[symbol][tf].top5Positive = positives;
                this.oiHistory[symbol][tf].top5Negative = negatives;
              });
            });
          }
          
          // Merge timestamps
          if (data.timestamps) {
            Object.keys(data.timestamps).forEach(symbol => {
              if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
              Object.keys(data.timestamps[symbol]).forEach(tf => {
                if (!this.timestamps[symbol][tf]) this.timestamps[symbol][tf] = {};
                Object.keys(data.timestamps[symbol][tf]).forEach(metric => {
                  if (!this.timestamps[symbol][tf][metric]) {
                    this.timestamps[symbol][tf][metric] = data.timestamps[symbol][tf][metric];
                  } else {
                    // Take oldest oldest and newest lastUpdate
                    const existing = this.timestamps[symbol][tf][metric];
                    const imported = data.timestamps[symbol][tf][metric];
                    this.timestamps[symbol][tf][metric] = {
                      oldest: new Date(existing.oldest) < new Date(imported.oldest) ? existing.oldest : imported.oldest,
                      lastUpdate: new Date(existing.lastUpdate) > new Date(imported.lastUpdate) ? existing.lastUpdate : imported.lastUpdate
                    };
                  }
                });
              });
            });
          }
          
          // Merge lastFetch
          if (data.lastFetch) {
            Object.keys(data.lastFetch).forEach(key => {
              if (!this.state.lastFetch[key] || new Date(data.lastFetch[key]) > new Date(this.state.lastFetch[key])) {
                this.state.lastFetch[key] = data.lastFetch[key];
              }
            });
          }
          
          // Merge symbols
          if (data.symbols) {
            const symbolSet = new Set([...this.state.symbols, ...data.symbols]);
            this.state.symbols = Array.from(symbolSet);
          }
          
          this.updateTimestampCache();
          await this.saveAllData();
          
          alert('Data imported successfully!');
          this.state.showImportPrompt = false;
          this.render();
        } catch (error) {
          alert('Error importing data: ' + error.message);
        }
      }

      exportData() {
        const data = {
          extremes: null,
          oiHistory: this.oiHistory,
          timestamps: this.timestamps,
          lastFetch: this.state.lastFetch,
          symbols: this.state.symbols,
          exportDate: new Date().toISOString()
        };
        
        storage.get('vercel-scanner-extremes').then(result => {
          if (result) {
            data.extremes = JSON.parse(result.value);
          }
          
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `vercel-scanner-data-${new Date().toISOString().split('T')[0]}.json`;
          a.click();
          URL.revokeObjectURL(url);
        });
      }

      async fillGaps() {
        if (!this.state.initialized || this.state.symbols.length === 0) {
          alert('Please initialize scanner first');
          return;
        }
        
        this.state.loading = true;
        this.state.progress = { current: 0, total: 0 };
        this.render();
        
        try {
          const extremesData = await storage.get('vercel-scanner-extremes');
          const extremesDB = extremesData ? JSON.parse(extremesData.value) : {};
          
          // Find missing data
          const missing = [];
          this.state.symbols.forEach(symbol => {
            TIMEFRAMES.forEach(tf => {
              const key = `${symbol}_${tf}`;
              const lastFetchTime = this.state.lastFetch[key] ? new Date(this.state.lastFetch[key]) : null;
              const now = new Date();
              
              // Check if missing or stale (older than 1 hour)
              if (!lastFetchTime || (now - lastFetchTime) > 3600000) {
                missing.push({ symbol, tf });
              }
            });
          });
          
          this.state.progress.total = missing.length;
          this.render();
          
          // Fetch missing data in batches of 20
          for (let i = 0; i < missing.length; i += 20) {
            const batch = missing.slice(i, i + 20);
            await Promise.all(batch.map(async ({ symbol, tf }) => {
              try {
                await new Promise(resolve => setTimeout(resolve, 50));
                const klines = await fetch(
                  `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${tf}&limit=100`
                ).then(r => r.json());
                
                if (Array.isArray(klines) && klines.length > 0) {
                  if (!extremesDB[symbol]) extremesDB[symbol] = {};
                  if (!extremesDB[symbol][tf]) extremesDB[symbol][tf] = { volume: { top5: [] }, candleSize: { top5: [] } };
                  
                  const processed = klines.map(k => ({
                    time: k[0],
                    volume: parseFloat(k[5]),
                    candleSize: ((parseFloat(k[2]) - parseFloat(k[3])) / parseFloat(k[3])) * 100
                  }));
                  
                  const volumeSorted = [...processed].sort((a, b) => b.volume - a.volume);
                  const candleSorted = [...processed].sort((a, b) => b.candleSize - a.candleSize);
                  
                  // Merge with existing
                  const existingVol = extremesDB[symbol][tf].volume.top5 || [];
                  const existingCandle = extremesDB[symbol][tf].candleSize.top5 || [];
                  
                  const mergedVol = [...existingVol, ...volumeSorted].sort((a, b) => b.volume - a.volume).slice(0, 5);
                  const mergedCandle = [...existingCandle, ...candleSorted].sort((a, b) => b.candleSize - a.candleSize).slice(0, 5);
                  
                  extremesDB[symbol][tf] = {
                    volume: { top5: mergedVol },
                    candleSize: { top5: mergedCandle }
                  };
                  
                  // Update timestamps
                  if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
                  if (!this.timestamps[symbol][tf]) this.timestamps[symbol][tf] = {};
                  
                  const oldestTime = new Date(processed[0].time);
                  const newestTime = new Date(processed[processed.length - 1].time);
                  
                  if (!this.timestamps[symbol][tf].volume) {
                    this.timestamps[symbol][tf].volume = { oldest: oldestTime.toISOString(), lastUpdate: newestTime.toISOString() };
                  } else {
                    const existingOldest = new Date(this.timestamps[symbol][tf].volume.oldest);
                    this.timestamps[symbol][tf].volume.oldest = oldestTime < existingOldest ? oldestTime.toISOString() : this.timestamps[symbol][tf].volume.oldest;
                    this.timestamps[symbol][tf].volume.lastUpdate = newestTime.toISOString();
                  }
                  
                  if (!this.timestamps[symbol][tf].candle) {
                    this.timestamps[symbol][tf].candle = { oldest: oldestTime.toISOString(), lastUpdate: newestTime.toISOString() };
                  } else {
                    const existingOldest = new Date(this.timestamps[symbol][tf].candle.oldest);
                    this.timestamps[symbol][tf].candle.oldest = oldestTime < existingOldest ? oldestTime.toISOString() : this.timestamps[symbol][tf].candle.oldest;
                    this.timestamps[symbol][tf].candle.lastUpdate = newestTime.toISOString();
                  }
                  
                  this.state.lastFetch[`${symbol}_${tf}`] = new Date().toISOString();
                }
                
                this.state.progress.current++;
                this.render();
              } catch (error) {
                console.error(`Error filling gap for ${symbol} ${tf}:`, error);
                this.state.progress.current++;
                this.render();
              }
            }));
          }
          
          await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
          await storage.set('vercel-scanner-timestamps', JSON.stringify(this.timestamps));
          await storage.set('vercel-scanner-init', JSON.stringify({
            initialized: true,
            lastFetch: this.state.lastFetch,
            symbols: this.state.symbols
          }));
          
          this.updateTimestampCache();
          await this.saveAllData();
          
          this.state.loading = false;
          this.render();
          alert('Gaps filled successfully!');
        } catch (error) {
          console.error('Gap filling error:', error);
          alert('Error: ' + error.message);
          this.state.loading = false;
          this.render();
        }
      }

      async initializeScanner() {
        console.log('Initialize button clicked');
        this.state.loading = true;
        this.state.progress = { current: 0, total: 0 };
        this.state.showImportPrompt = false;
        this.render();

        try {
          const exchangeInfo = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo').then(r => r.json());
          const perpetuals = exchangeInfo.symbols
            .filter(s => s.contractType === 'PERPETUAL' && !s.symbol.includes('_'))
            .map(s => s.symbol);

          this.state.symbols = perpetuals;
          this.state.progress.total = perpetuals.length * TIMEFRAMES.length;
          this.render();

          const fetchData = {};
          const extremesDB = {};

          // Process in batches of 20
          for (let i = 0; i < perpetuals.length; i += 20) {
            const batch = perpetuals.slice(i, i + 20);
            
            await Promise.all(batch.map(async (symbol) => {
              if (!extremesDB[symbol]) extremesDB[symbol] = {};
              
              for (const tf of TIMEFRAMES) {
                try {
                  await new Promise(resolve => setTimeout(resolve, 50));
                  const klines = await fetch(
                    `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${tf}&limit=100`
                  ).then(r => r.json());

                  if (!Array.isArray(klines) || klines.length === 0) continue;

                  const processed = klines.map(k => ({
                    time: k[0],
                    volume: parseFloat(k[5]),
                    candleSize: ((parseFloat(k[2]) - parseFloat(k[3])) / parseFloat(k[3])) * 100
                  }));

                  const volumeSorted = [...processed].sort((a, b) => b.volume - a.volume);
                  const candleSorted = [...processed].sort((a, b) => b.candleSize - a.candleSize);

                  extremesDB[symbol][tf] = {
                    volume: { top5: volumeSorted.slice(0, 5) },
                    candleSize: { top5: candleSorted.slice(0, 5) }
                  };

                  // Store timestamps
                  if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
                  if (!this.timestamps[symbol][tf]) this.timestamps[symbol][tf] = {};
                  
                  const oldestTime = new Date(processed[0].time);
                  const newestTime = new Date(processed[processed.length - 1].time);
                  
                  this.timestamps[symbol][tf].volume = {
                    oldest: oldestTime.toISOString(),
                    lastUpdate: newestTime.toISOString()
                  };
                  this.timestamps[symbol][tf].candle = {
                    oldest: oldestTime.toISOString(),
                    lastUpdate: newestTime.toISOString()
                  };

                  fetchData[`${symbol}_${tf}`] = new Date().toISOString();
                  this.state.progress.current++;
                  this.render();
                } catch (error) {
                  console.error(`Error fetching ${symbol} ${tf}:`, error);
                }
              }
            }));
          }

          await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
          await storage.set('vercel-scanner-timestamps', JSON.stringify(this.timestamps));
          await storage.set('vercel-scanner-init', JSON.stringify({
            initialized: true,
            lastFetch: fetchData,
            symbols: perpetuals
          }));

          this.state.lastFetch = fetchData;
          this.state.initialized = true;
          this.state.loading = false;
          
          this.updateTimestampCache();
          await this.saveAllData();
          
          this.render();
          this.startLiveMonitoring(perpetuals);
        } catch (error) {
          console.error('Initialization error:', error);
          alert('Error: ' + error.message);
          this.state.loading = false;
          this.render();
        }
      }

      startLiveMonitoring(symbolsList) {
        this.wsRefs.forEach(ws => ws.close());
        this.wsRefs = [];

        const streams = [];
        symbolsList.slice(0, 200).forEach(symbol => {
          TIMEFRAMES.forEach(tf => streams.push(`${symbol.toLowerCase()}@kline_${tf}`));
        });

        const ws = new WebSocket(`wss://fstream.binance.com/stream?streams=${streams.join('/')}`);
        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          if (data.data && data.data.k && data.data.k.x) this.processCandle(data.data);
        };
        this.wsRefs.push(ws);
      }

      async processCandle(klineData) {
        const { s: symbol, k } = klineData;
        const { i: interval, h: high, l: low, v: volume, T: closeTime } = k;
        const candleSize = ((parseFloat(high) - parseFloat(low)) / parseFloat(low)) * 100;
        const vol = parseFloat(volume);

        const extremesData = await storage.get('vercel-scanner-extremes');
        if (!extremesData) return;

        const extremesDB = JSON.parse(extremesData.value);
        if (!extremesDB[symbol] || !extremesDB[symbol][interval]) return;

        const extremes = extremesDB[symbol][interval];

        if (vol > 0 && extremes.volume.top5.length > 0) {
          const top5Vol = extremes.volume.top5;
          if (top5Vol.length < 5 || vol > top5Vol[4].volume) {
            const newEntry = { time: closeTime, volume: vol };
            const merged = [...top5Vol, newEntry].sort((a, b) => b.volume - a.volume).slice(0, 5);
            extremesDB[symbol][interval].volume.top5 = merged;
            await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
            
            // Update timestamp
            if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
            if (!this.timestamps[symbol][interval]) this.timestamps[symbol][interval] = {};
            if (!this.timestamps[symbol][interval].volume) {
              this.timestamps[symbol][interval].volume = { oldest: new Date(closeTime).toISOString(), lastUpdate: new Date(closeTime).toISOString() };
            } else {
              this.timestamps[symbol][interval].volume.lastUpdate = new Date(closeTime).toISOString();
            }
            
            const rank = merged.findIndex(v => v.time === closeTime) + 1;
            this.addAlert(ALERT_FEEDS.find(f => f.timeframes.includes(interval))?.id, {
              symbol,
              type: 'volume',
              subtype: `Top 5 Volume: #${rank}`,
              value: vol.toFixed(2),
              timeframe: interval,
              timestamp: new Date(closeTime)
            });
          }
        }

        if (candleSize > 0 && extremes.candleSize.top5.length > 0) {
          const top5Candle = extremes.candleSize.top5;
          if (top5Candle.length < 5 || candleSize > top5Candle[4].candleSize) {
            const newEntry = { time: closeTime, candleSize: candleSize };
            const merged = [...top5Candle, newEntry].sort((a, b) => b.candleSize - a.candleSize).slice(0, 5);
            extremesDB[symbol][interval].candleSize.top5 = merged;
            await storage.set('vercel-scanner-extremes', JSON.stringify(extremesDB));
            
            // Update timestamp
            if (!this.timestamps[symbol]) this.timestamps[symbol] = {};
            if (!this.timestamps[symbol][interval]) this.timestamps[symbol][interval] = {};
            if (!this.timestamps[symbol][interval].candle) {
              this.timestamps[symbol][interval].candle = { oldest: new Date(closeTime).toISOString(), lastUpdate: new Date(closeTime).toISOString() };
            } else {
              this.timestamps[symbol][interval].candle.lastUpdate = new Date(closeTime).toISOString();
            }
            
            const rank = merged.findIndex(c => c.time === closeTime) + 1;
            this.addAlert(ALERT_FEEDS.find(f => f.timeframes.includes(interval))?.id, {
              symbol,
              type: 'candleSize',
              subtype: `Top 5 Candle Size: #${rank}`,
              value: candleSize.toFixed(2) + '%',
              timeframe: interval,
              timestamp: new Date(closeTime)
            });
          }
        }
        
        this.updateTimestampCache();
        await this.saveAllData();
      }

      addAlert(feedId, alert) {
        if (!feedId || this.state.pausedFeeds[feedId]) return;
        this.state.alerts[feedId] = [alert, ...this.state.alerts[feedId]].slice(0, 100);
        this.audioEl.play().catch(e => console.log('Audio play failed'));
        this.render();
      }

      toggleFeedPause(feedId) {
        this.state.pausedFeeds[feedId] = !this.state.pausedFeeds[feedId];
        this.render();
      }

      toggleExplorer() {
        this.state.showExplorer = !this.state.showExplorer;
        this.render();
      }

      selectSymbol(symbol) {
        this.state.selectedSymbol = symbol;
        this.render();
      }

      formatTimeAgo(dateStr) {
        if (!dateStr) return 'N/A';
        const date = new Date(dateStr);
        const now = new Date();
        const diffMs = now - date;
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffHours / 24);
        
        if (diffDays > 0) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        if (diffHours > 0) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        return 'Just now';
      }

      formatDate(dateStr) {
        if (!dateStr) return 'N/A';
        return new Date(dateStr).toLocaleDateString();
      }

      getExplorerData() {
        if (!this.state.selectedSymbol) return null;
        
        const symbol = this.state.selectedSymbol;
        const extremesData = storage.get('vercel-scanner-extremes');
        let extremesDB = {};
        
        // Get extremes data synchronously for display
        try {
          const stored = localStorage.getItem('vercel-scanner-extremes');
          if (stored) extremesDB = JSON.parse(stored);
        } catch (e) {}
        
        const data = {
          symbol,
          timeframes: {}
        };
        
        TIMEFRAMES.forEach(tf => {
          data.timeframes[tf] = {
            volume: extremesDB[symbol]?.[tf]?.volume?.top5 || [],
            candleSize: extremesDB[symbol]?.[tf]?.candleSize?.top5 || [],
            oiPositive: this.oiHistory[symbol]?.[tf]?.top5Positive || [],
            oiNegative: this.oiHistory[symbol]?.[tf]?.top5Negative || []
          };
        });
        
        return data;
      }

      render() {
        const root = document.getElementById('root');
        const s = this.state;
        
        // Info tooltip content
        const getInfoTooltip = () => {
          if (!this.timestampCache || Object.keys(this.timestampCache).length === 0) {
            return '<div class="text-gray-400 text-sm">No data available</div>';
          }
          
          let html = '<div class="space-y-2 text-sm">';
          TIMEFRAMES.forEach(tf => {
            ['volume', 'candle', 'oi'].forEach(metric => {
              const key = `${tf}_${metric}`;
              const cache = this.timestampCache[key];
              if (cache) {
                const oldestMin = new Date(cache.oldestMin);
                const oldestMax = new Date(cache.oldestMax);
                const lastUpdate = new Date(cache.lastUpdateMin);
                
                const oldestMinStr = oldestMin.toLocaleDateString();
                const oldestMaxStr = oldestMax.toLocaleDateString();
                const oldestRange = oldestMinStr === oldestMaxStr 
                  ? oldestMinStr 
                  : `${oldestMinStr} (${cache.oldestMinCoin}) - ${oldestMaxStr} (${cache.oldestMaxCoin})`;
                
                html += `
                  <div class="border-b border-gray-700 pb-2">
                    <div class="font-semibold text-yellow-400">${tf.toUpperCase()} ${metric.toUpperCase()}</div>
                    <div class="text-gray-300">Oldest: ${oldestRange}</div>
                    <div class="text-gray-300">Last updated: ${this.formatDate(cache.lastUpdateMin)} (${this.formatTimeAgo(cache.lastUpdateMin)})</div>
                  </div>
                `;
              }
            });
          });
          html += '</div>';
          return html;
        };
        
        root.innerHTML = `
          <div class="flex items-center justify-between mb-6">
            <h1 class="text-3xl font-bold">Vercel Scanner</h1>
            <div class="flex items-center gap-4">
              ${s.initialized ? `
                <button onclick="scanner.exportData()" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded">
                  Export Data
                </button>
                <button onclick="scanner.fillGaps()" ${s.loading ? 'disabled' : ''} 
                  class="px-4 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 rounded">
                  Fill Gaps
                </button>
                <button onclick="scanner.toggleExplorer()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded">
                  ${s.showExplorer ? 'Hide' : 'Show'} Explorer
                </button>
              ` : ''}
              <div class="relative">
                <button onmouseenter="scanner.state.showInfo = true; scanner.render()" 
                        onmouseleave="scanner.state.showInfo = false; scanner.render()"
                        class="p-2 bg-gray-700 hover:bg-gray-600 rounded text-xl">
                  ℹ️
                </button>
                ${s.showInfo ? `
                  <div class="absolute right-0 top-full mt-2 w-96 bg-gray-800 rounded-lg p-4 shadow-xl z-50 border border-gray-700">
                    ${getInfoTooltip()}
                  </div>
                ` : ''}
              </div>
            </div>
          </div>

          ${s.showImportPrompt ? `
            <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
              <div class="bg-gray-800 rounded-lg p-6 max-w-md">
                <h2 class="text-xl font-bold mb-4">Import Existing Data?</h2>
                <p class="text-gray-300 mb-4">Do you want to import previously exported data before initializing?</p>
                <div class="flex gap-4">
                  <input type="file" id="importFile" accept=".json" class="hidden" 
                         onchange="scanner.importData(this.files[0])">
                  <label for="importFile" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded cursor-pointer">
                    Import Data
                  </label>
                  <button onclick="scanner.state.showImportPrompt = false; scanner.render()" 
                          class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded">
                    Skip
                  </button>
                </div>
              </div>
            </div>
          ` : ''}

          ${!s.initialized ? `
            <div class="flex flex-col items-center justify-center mt-20">
              <button onclick="scanner.initializeScanner()" ${s.loading ? 'disabled' : ''} 
                class="px-8 py-4 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded-lg text-lg font-semibold">
                ${s.loading ? 'Initializing...' : 'Initialize Scanner'}
              </button>
              ${s.loading ? `
                <div class="mt-8 w-96 bg-gray-800 rounded-lg p-4">
                  <div class="text-center mb-2">
                    Loading ${s.progress.current}/${s.progress.total} (${Math.round((s.progress.current / s.progress.total) * 100)}%)
                  </div>
                  <div class="w-full bg-gray-700 rounded-full h-4">
                    <div class="bg-blue-600 h-4 rounded-full transition-all" 
                      style="width: ${(s.progress.current / s.progress.total) * 100}%"></div>
                  </div>
                  <div class="text-xs text-gray-400 mt-2 text-center">
                    This will take 3-5 minutes. Fetching historical data...
                  </div>
                </div>
              ` : ''}
            </div>
          ` : `
            ${s.showExplorer ? `
              <div class="mb-6 bg-gray-800 rounded-lg p-4">
                <div class="mb-4">
                  <label class="block text-sm font-semibold mb-2">Select Coin:</label>
                  <input type="text" id="coinSearch" placeholder="Search coin..." 
                         oninput="scanner.filterCoins(this.value)"
                         class="w-full px-4 py-2 bg-gray-700 rounded text-white mb-2">
                  <select id="coinSelect" onchange="scanner.selectSymbol(this.value)" 
                          class="w-full px-4 py-2 bg-gray-700 rounded text-white">
                    <option value="">-- Select a coin --</option>
                    ${s.symbols.map(sym => `<option value="${sym}" ${sym === s.selectedSymbol ? 'selected' : ''}>${sym}</option>`).join('')}
                  </select>
                </div>
                ${s.selectedSymbol ? (() => {
                  const explorerData = this.getExplorerData();
                  if (!explorerData) return '<div class="text-gray-400">Loading...</div>';
                  
                  return `
                    <div class="space-y-4">
                      <h3 class="text-xl font-bold">${explorerData.symbol}</h3>
                      ${TIMEFRAMES.map(tf => {
                        const tfData = explorerData.timeframes[tf];
                        return `
                          <div class="bg-gray-900 rounded p-4">
                            <h4 class="font-semibold text-lg mb-3">${tf}</h4>
                            <div class="grid grid-cols-2 gap-4">
                              <div>
                                <h5 class="font-semibold text-green-400 mb-2">Top 5 OI Increases (%)</h5>
                                ${tfData.oiPositive.length > 0 ? tfData.oiPositive.map((oi, idx) => `
                                  <div class="text-sm mb-1">
                                    #${idx + 1}: ${oi.percent.toFixed(2)}% (${new Date(oi.timestamp).toLocaleString()})
                                  </div>
                                `).join('') : '<div class="text-gray-500 text-sm">No data</div>'}
                              </div>
                              <div>
                                <h5 class="font-semibold text-red-400 mb-2">Top 5 OI Decreases (%)</h5>
                                ${tfData.oiNegative.length > 0 ? tfData.oiNegative.map((oi, idx) => `
                                  <div class="text-sm mb-1">
                                    #${idx + 1}: ${oi.percent.toFixed(2)}% (${new Date(oi.timestamp).toLocaleString()})
                                  </div>
                                `).join('') : '<div class="text-gray-500 text-sm">No data</div>'}
                              </div>
                              <div>
                                <h5 class="font-semibold text-blue-400 mb-2">Top 5 Volume</h5>
                                ${tfData.volume.length > 0 ? tfData.volume.map((vol, idx) => `
                                  <div class="text-sm mb-1">
                                    #${idx + 1}: ${vol.volume.toFixed(2)} (${new Date(vol.time).toLocaleString()})
                                  </div>
                                `).join('') : '<div class="text-gray-500 text-sm">No data</div>'}
                              </div>
                              <div>
                                <h5 class="font-semibold text-yellow-400 mb-2">Top 5 Candle Size (%)</h5>
                                ${tfData.candleSize.length > 0 ? tfData.candleSize.map((candle, idx) => `
                                  <div class="text-sm mb-1">
                                    #${idx + 1}: ${candle.candleSize.toFixed(2)}% (${new Date(candle.time).toLocaleString()})
                                  </div>
                                `).join('') : '<div class="text-gray-500 text-sm">No data</div>'}
                              </div>
                            </div>
                          </div>
                        `;
                      }).join('')}
                    </div>
                  `;
                })() : '<div class="text-gray-400">Select a coin to view data</div>'}
              </div>
            ` : ''}
            <div class="grid grid-cols-3 gap-4">
              ${ALERT_FEEDS.map(feed => `
                <div class="bg-gray-800 rounded-lg p-4">
                  <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-semibold">${feed.name}</h2>
                    <button onclick="scanner.toggleFeedPause('${feed.id}')" 
                      class="p-2 bg-gray-700 hover:bg-gray-600 rounded">
                      ${s.pausedFeeds[feed.id] ? '▶' : '⏸'}
                    </button>
                  </div>
                  <div class="space-y-2 max-h-[600px] overflow-y-auto">
                    ${s.alerts[feed.id].length === 0 ? `
                      <div class="text-gray-500 text-sm text-center py-8">
                        No alerts yet. Monitoring live...
                      </div>
                    ` : s.alerts[feed.id].map(alert => `
                      <div class="bg-gray-900 rounded p-3 text-sm border-l-4 border-yellow-500">
                        <div class="flex items-start justify-between">
                          <span class="font-bold">${alert.symbol}</span>
                          <span class="text-gray-400 text-xs">${alert.timeframe}</span>
                        </div>
                        <div class="mt-1 text-yellow-400">${alert.subtype}</div>
                        <div class="mt-1 text-gray-300">Value: ${alert.value}</div>
                        <div class="mt-1 text-gray-500 text-xs">
                          ${alert.timestamp.toLocaleString()}
                        </div>
                      </div>
                    `).join('')}
                  </div>
                </div>
              `).join('')}
            </div>
          `}
        `;
      }

      filterCoins(searchTerm) {
        const select = document.getElementById('coinSelect');
        if (!select) return;
        
        const options = Array.from(select.options);
        const searchLower = searchTerm.toLowerCase();
        options.forEach(option => {
          if (option.value === '') return;
          const matches = option.textContent.toLowerCase().includes(searchLower);
          option.style.display = matches ? '' : 'none';
        });
        
        // Auto-select first visible option if current selection is hidden
        if (this.state.selectedSymbol) {
          const selectedOption = Array.from(select.options).find(opt => opt.value === this.state.selectedSymbol);
          if (selectedOption && selectedOption.style.display === 'none') {
            const firstVisible = Array.from(select.options).find(opt => opt.value !== '' && opt.style.display !== 'none');
            if (firstVisible) {
              this.selectSymbol(firstVisible.value);
            }
          }
        }
      }
    }

    const scanner = new Scanner();
    window.scanner = scanner;
  </script>
</body>
</html>
